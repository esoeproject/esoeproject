// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX_HOME_KAURM_DEV_WORKSPACE_TEMPESOEPROJ_ESOEPROJECT_SAML2CPP_SCHEMA_SOAP_1_2_ENVELOPE_HXX
#define CXX_HOME_KAURM_DEV_WORKSPACE_TEMPESOEPROJ_ESOEPROJECT_SAML2CPP_SCHEMA_SOAP_1_2_ENVELOPE_HXX

// Begin prologue.
//
#include "saml2/SAML2Defs.h"
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3020000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

#include "saml2/xsd/xml-schema.hxx"

// Forward declarations.
//
namespace soap
{
  namespace v12
  {
    class Envelope;
    class Header;
    class Body;
    class Fault;
    class faultreason;
    class reasontext;
    class faultcode;
    class faultcodeEnum;
    class subcode;
    class detail;
    class NotUnderstoodType;
    class SupportedEnvType;
    class UpgradeType;
  }
}


#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

#include "xml.hxx"

namespace soap
{
  namespace v12
  {
    class Envelope: public ::xml_schema::type
    {
      public:
      // Header
      // 
      typedef ::soap::v12::Header Header_type;
      typedef ::xsd::cxx::tree::optional< Header_type > Header_optional;
      typedef ::xsd::cxx::tree::traits< Header_type, wchar_t > Header_traits;

      const Header_optional&
      Header () const;

      Header_optional&
      Header ();

      void
      Header (const Header_type& x);

      void
      Header (const Header_optional& x);

      void
      Header (::std::auto_ptr< Header_type > p);

      // Body
      // 
      typedef ::soap::v12::Body Body_type;
      typedef ::xsd::cxx::tree::traits< Body_type, wchar_t > Body_traits;

      const Body_type&
      Body () const;

      Body_type&
      Body ();

      void
      Body (const Body_type& x);

      void
      Body (::std::auto_ptr< Body_type > p);

      // any_attribute
      // 
      typedef ::xsd::cxx::tree::attribute_set< wchar_t > any_attribute_set;
      typedef any_attribute_set::iterator any_attribute_iterator;
      typedef any_attribute_set::const_iterator any_attribute_const_iterator;

      const any_attribute_set&
      any_attribute () const;

      any_attribute_set&
      any_attribute ();

      void
      any_attribute (const any_attribute_set& s);

      // DOMDocument for wildcard content.
      //
      const ::xercesc::DOMDocument&
      dom_document () const;

      ::xercesc::DOMDocument&
      dom_document ();

      // Constructors.
      //
      Envelope ();

      Envelope (const Body_type&);

      Envelope (::std::auto_ptr< Body_type >&);

      Envelope (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      Envelope (const Envelope& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual Envelope*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~Envelope ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > dom_document_;

      Header_optional Header_;
      ::xsd::cxx::tree::one< Body_type > Body_;
      any_attribute_set any_attribute_;
    };

    class Header: public ::xml_schema::type
    {
      public:
      // any
      // 
      typedef ::xsd::cxx::tree::element_sequence any_sequence;
      typedef any_sequence::iterator any_iterator;
      typedef any_sequence::const_iterator any_const_iterator;

      const any_sequence&
      any () const;

      any_sequence&
      any ();

      void
      any (const any_sequence& s);

      // any_attribute
      // 
      typedef ::xsd::cxx::tree::attribute_set< wchar_t > any_attribute_set;
      typedef any_attribute_set::iterator any_attribute_iterator;
      typedef any_attribute_set::const_iterator any_attribute_const_iterator;

      const any_attribute_set&
      any_attribute () const;

      any_attribute_set&
      any_attribute ();

      void
      any_attribute (const any_attribute_set& s);

      // DOMDocument for wildcard content.
      //
      const ::xercesc::DOMDocument&
      dom_document () const;

      ::xercesc::DOMDocument&
      dom_document ();

      // Constructors.
      //
      Header ();

      Header (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      Header (const Header& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual Header*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~Header ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > dom_document_;

      any_sequence any_;
      any_attribute_set any_attribute_;
    };

    class Body: public ::xml_schema::type
    {
      public:
      // any
      // 
      typedef ::xsd::cxx::tree::element_sequence any_sequence;
      typedef any_sequence::iterator any_iterator;
      typedef any_sequence::const_iterator any_const_iterator;

      const any_sequence&
      any () const;

      any_sequence&
      any ();

      void
      any (const any_sequence& s);

      // any_attribute
      // 
      typedef ::xsd::cxx::tree::attribute_set< wchar_t > any_attribute_set;
      typedef any_attribute_set::iterator any_attribute_iterator;
      typedef any_attribute_set::const_iterator any_attribute_const_iterator;

      const any_attribute_set&
      any_attribute () const;

      any_attribute_set&
      any_attribute ();

      void
      any_attribute (const any_attribute_set& s);

      // DOMDocument for wildcard content.
      //
      const ::xercesc::DOMDocument&
      dom_document () const;

      ::xercesc::DOMDocument&
      dom_document ();

      // Constructors.
      //
      Body ();

      Body (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      Body (const Body& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual Body*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~Body ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > dom_document_;

      any_sequence any_;
      any_attribute_set any_attribute_;
    };

    class Fault: public ::xml_schema::type
    {
      public:
      // Code
      // 
      typedef ::soap::v12::faultcode Code_type;
      typedef ::xsd::cxx::tree::traits< Code_type, wchar_t > Code_traits;

      const Code_type&
      Code () const;

      Code_type&
      Code ();

      void
      Code (const Code_type& x);

      void
      Code (::std::auto_ptr< Code_type > p);

      // Reason
      // 
      typedef ::soap::v12::faultreason Reason_type;
      typedef ::xsd::cxx::tree::traits< Reason_type, wchar_t > Reason_traits;

      const Reason_type&
      Reason () const;

      Reason_type&
      Reason ();

      void
      Reason (const Reason_type& x);

      void
      Reason (::std::auto_ptr< Reason_type > p);

      // Node
      // 
      typedef ::xml_schema::uri Node_type;
      typedef ::xsd::cxx::tree::optional< Node_type > Node_optional;
      typedef ::xsd::cxx::tree::traits< Node_type, wchar_t > Node_traits;

      const Node_optional&
      Node () const;

      Node_optional&
      Node ();

      void
      Node (const Node_type& x);

      void
      Node (const Node_optional& x);

      void
      Node (::std::auto_ptr< Node_type > p);

      // Role
      // 
      typedef ::xml_schema::uri Role_type;
      typedef ::xsd::cxx::tree::optional< Role_type > Role_optional;
      typedef ::xsd::cxx::tree::traits< Role_type, wchar_t > Role_traits;

      const Role_optional&
      Role () const;

      Role_optional&
      Role ();

      void
      Role (const Role_type& x);

      void
      Role (const Role_optional& x);

      void
      Role (::std::auto_ptr< Role_type > p);

      // Detail
      // 
      typedef ::soap::v12::detail Detail_type;
      typedef ::xsd::cxx::tree::optional< Detail_type > Detail_optional;
      typedef ::xsd::cxx::tree::traits< Detail_type, wchar_t > Detail_traits;

      const Detail_optional&
      Detail () const;

      Detail_optional&
      Detail ();

      void
      Detail (const Detail_type& x);

      void
      Detail (const Detail_optional& x);

      void
      Detail (::std::auto_ptr< Detail_type > p);

      // Constructors.
      //
      Fault ();

      Fault (const Code_type&,
             const Reason_type&);

      Fault (::std::auto_ptr< Code_type >&,
             ::std::auto_ptr< Reason_type >&);

      Fault (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      Fault (const Fault& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      virtual Fault*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~Fault ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Code_type > Code_;
      ::xsd::cxx::tree::one< Reason_type > Reason_;
      Node_optional Node_;
      Role_optional Role_;
      Detail_optional Detail_;
    };

    class faultreason: public ::xml_schema::type
    {
      public:
      // Text
      // 
      typedef ::soap::v12::reasontext Text_type;
      typedef ::xsd::cxx::tree::sequence< Text_type > Text_sequence;
      typedef Text_sequence::iterator Text_iterator;
      typedef Text_sequence::const_iterator Text_const_iterator;
      typedef ::xsd::cxx::tree::traits< Text_type, wchar_t > Text_traits;

      const Text_sequence&
      Text () const;

      Text_sequence&
      Text ();

      void
      Text (const Text_sequence& s);

      // Constructors.
      //
      faultreason ();

      faultreason (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      faultreason (const faultreason& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual faultreason*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~faultreason ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      Text_sequence Text_;
    };

    class reasontext: public ::xml_schema::string
    {
      public:
      // lang
      // 
      typedef ::namespace_::lang lang_type;
      typedef ::xsd::cxx::tree::traits< lang_type, wchar_t > lang_traits;

      const lang_type&
      lang () const;

      lang_type&
      lang ();

      void
      lang (const lang_type& x);

      void
      lang (::std::auto_ptr< lang_type > p);

      // Constructors.
      //
      reasontext ();

      reasontext (const lang_type&);

      reasontext (const wchar_t*,
                  const lang_type&);

      reasontext (const ::std::wstring&,
                  const lang_type&);

      reasontext (const ::xml_schema::string&,
                  const lang_type&);

      reasontext (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      reasontext (const reasontext& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual reasontext*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~reasontext ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< lang_type > lang_;
    };

    class faultcode: public ::xml_schema::type
    {
      public:
      // Value
      // 
      typedef ::soap::v12::faultcodeEnum Value_type;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_type&
      Value () const;

      Value_type&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (::std::auto_ptr< Value_type > p);

      // Subcode
      // 
      typedef ::soap::v12::subcode Subcode_type;
      typedef ::xsd::cxx::tree::optional< Subcode_type > Subcode_optional;
      typedef ::xsd::cxx::tree::traits< Subcode_type, wchar_t > Subcode_traits;

      const Subcode_optional&
      Subcode () const;

      Subcode_optional&
      Subcode ();

      void
      Subcode (const Subcode_type& x);

      void
      Subcode (const Subcode_optional& x);

      void
      Subcode (::std::auto_ptr< Subcode_type > p);

      // Constructors.
      //
      faultcode ();

      faultcode (const Value_type&);

      faultcode (::std::auto_ptr< Value_type >&);

      faultcode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      faultcode (const faultcode& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual faultcode*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~faultcode ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Value_type > Value_;
      Subcode_optional Subcode_;
    };

    class faultcodeEnum: public ::xml_schema::qname
    {
      public:
      faultcodeEnum ();

      faultcodeEnum (const ::xml_schema::qname& v);

      faultcodeEnum (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      faultcodeEnum (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      faultcodeEnum (const ::std::wstring& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      faultcodeEnum (const faultcodeEnum& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual faultcodeEnum*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;
    };

    class subcode: public ::xml_schema::type
    {
      public:
      // Value
      // 
      typedef ::xml_schema::qname Value_type;
      typedef ::xsd::cxx::tree::traits< Value_type, wchar_t > Value_traits;

      const Value_type&
      Value () const;

      Value_type&
      Value ();

      void
      Value (const Value_type& x);

      void
      Value (::std::auto_ptr< Value_type > p);

      // Subcode
      // 
      typedef ::soap::v12::subcode Subcode_type;
      typedef ::xsd::cxx::tree::optional< Subcode_type > Subcode_optional;
      typedef ::xsd::cxx::tree::traits< Subcode_type, wchar_t > Subcode_traits;

      const Subcode_optional&
      Subcode () const;

      Subcode_optional&
      Subcode ();

      void
      Subcode (const Subcode_type& x);

      void
      Subcode (const Subcode_optional& x);

      void
      Subcode (::std::auto_ptr< Subcode_type > p);

      // Constructors.
      //
      subcode ();

      subcode (const Value_type&);

      subcode (::std::auto_ptr< Value_type >&);

      subcode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      subcode (const subcode& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      virtual subcode*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~subcode ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Value_type > Value_;
      Subcode_optional Subcode_;
    };

    class detail: public ::xml_schema::type
    {
      public:
      // any
      // 
      typedef ::xsd::cxx::tree::element_sequence any_sequence;
      typedef any_sequence::iterator any_iterator;
      typedef any_sequence::const_iterator any_const_iterator;

      const any_sequence&
      any () const;

      any_sequence&
      any ();

      void
      any (const any_sequence& s);

      // any_attribute
      // 
      typedef ::xsd::cxx::tree::attribute_set< wchar_t > any_attribute_set;
      typedef any_attribute_set::iterator any_attribute_iterator;
      typedef any_attribute_set::const_iterator any_attribute_const_iterator;

      const any_attribute_set&
      any_attribute () const;

      any_attribute_set&
      any_attribute ();

      void
      any_attribute (const any_attribute_set& s);

      // DOMDocument for wildcard content.
      //
      const ::xercesc::DOMDocument&
      dom_document () const;

      ::xercesc::DOMDocument&
      dom_document ();

      // Constructors.
      //
      detail ();

      detail (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      detail (const detail& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual detail*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~detail ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > dom_document_;

      any_sequence any_;
      any_attribute_set any_attribute_;
    };

    class NotUnderstoodType: public ::xml_schema::type
    {
      public:
      // qname
      // 
      typedef ::xml_schema::qname qname_type;
      typedef ::xsd::cxx::tree::traits< qname_type, wchar_t > qname_traits;

      const qname_type&
      qname () const;

      qname_type&
      qname ();

      void
      qname (const qname_type& x);

      void
      qname (::std::auto_ptr< qname_type > p);

      // Constructors.
      //
      NotUnderstoodType ();

      NotUnderstoodType (const qname_type&);

      NotUnderstoodType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      NotUnderstoodType (const NotUnderstoodType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual NotUnderstoodType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~NotUnderstoodType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< qname_type > qname_;
    };

    class SupportedEnvType: public ::xml_schema::type
    {
      public:
      // qname
      // 
      typedef ::xml_schema::qname qname_type;
      typedef ::xsd::cxx::tree::traits< qname_type, wchar_t > qname_traits;

      const qname_type&
      qname () const;

      qname_type&
      qname ();

      void
      qname (const qname_type& x);

      void
      qname (::std::auto_ptr< qname_type > p);

      // Constructors.
      //
      SupportedEnvType ();

      SupportedEnvType (const qname_type&);

      SupportedEnvType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SupportedEnvType (const SupportedEnvType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SupportedEnvType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~SupportedEnvType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< qname_type > qname_;
    };

    class UpgradeType: public ::xml_schema::type
    {
      public:
      // SupportedEnvelope
      // 
      typedef ::soap::v12::SupportedEnvType SupportedEnvelope_type;
      typedef ::xsd::cxx::tree::sequence< SupportedEnvelope_type > SupportedEnvelope_sequence;
      typedef SupportedEnvelope_sequence::iterator SupportedEnvelope_iterator;
      typedef SupportedEnvelope_sequence::const_iterator SupportedEnvelope_const_iterator;
      typedef ::xsd::cxx::tree::traits< SupportedEnvelope_type, wchar_t > SupportedEnvelope_traits;

      const SupportedEnvelope_sequence&
      SupportedEnvelope () const;

      SupportedEnvelope_sequence&
      SupportedEnvelope ();

      void
      SupportedEnvelope (const SupportedEnvelope_sequence& s);

      // Constructors.
      //
      UpgradeType ();

      UpgradeType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      UpgradeType (const UpgradeType& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual UpgradeType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~UpgradeType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      SupportedEnvelope_sequence SupportedEnvelope_;
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace soap
{
  namespace v12
  {
    // Parse a URI or a local file.
    //

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (const ::std::wstring& uri,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (const ::std::wstring& uri,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (const ::std::wstring& uri,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               const ::std::wstring& id,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               const ::std::wstring& id,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               const ::std::wstring& id,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::xercesc::InputSource& is,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::xercesc::InputSource& is,
               ::xml_schema::error_handler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::xercesc::InputSource& is,
               ::xercesc::DOMErrorHandler& eh,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f = 0,
               const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse a URI or a local file.
    //

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (const ::std::wstring& uri,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (const ::std::wstring& uri,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (const ::std::wstring& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             const ::std::wstring& id,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             const ::std::wstring& id,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             const ::std::wstring& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::xercesc::InputSource& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::xercesc::InputSource& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse a URI or a local file.
    //

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (const ::std::wstring& uri,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (const ::std::wstring& uri,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (const ::std::wstring& uri,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           const ::std::wstring& id,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           const ::std::wstring& id,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           const ::std::wstring& id,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::xercesc::InputSource& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::xercesc::InputSource& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::xercesc::InputSource& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse a URI or a local file.
    //

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (const ::std::wstring& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (const ::std::wstring& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (const ::std::wstring& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            const ::std::wstring& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            const ::std::wstring& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            const ::std::wstring& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse a URI or a local file.
    //

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (const ::std::wstring& uri,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (const ::std::wstring& uri,
                   ::xml_schema::error_handler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (const ::std::wstring& uri,
                   ::xercesc::DOMErrorHandler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   ::xml_schema::error_handler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   ::xercesc::DOMErrorHandler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   const ::std::wstring& id,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   const ::std::wstring& id,
                   ::xml_schema::error_handler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   const ::std::wstring& id,
                   ::xercesc::DOMErrorHandler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::xercesc::InputSource& is,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::xercesc::InputSource& is,
                   ::xml_schema::error_handler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::xercesc::InputSource& is,
                   ::xercesc::DOMErrorHandler& eh,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f = 0,
                   const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse a URI or a local file.
    //

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (const ::std::wstring& uri,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (const ::std::wstring& uri,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (const ::std::wstring& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             const ::std::wstring& id,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             const ::std::wstring& id,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             const ::std::wstring& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::xercesc::InputSource& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::xercesc::InputSource& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace soap
{
  namespace v12
  {
    // Serialize to std::ostream.
    //

    void
    Envelope_ (::std::ostream& os,
               const ::soap::v12::Envelope& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

    void
    Envelope_ (::std::ostream& os,
               const ::soap::v12::Envelope& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

    void
    Envelope_ (::std::ostream& os,
               const ::soap::v12::Envelope& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    Envelope_ (::xercesc::XMLFormatTarget& ft,
               const ::soap::v12::Envelope& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

    void
    Envelope_ (::xercesc::XMLFormatTarget& ft,
               const ::soap::v12::Envelope& x, 
               ::xml_schema::error_handler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

    void
    Envelope_ (::xercesc::XMLFormatTarget& ft,
               const ::soap::v12::Envelope& x, 
               ::xercesc::DOMErrorHandler& eh,
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               const ::std::wstring& e = L"UTF-8",
               ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    Envelope_ (::xercesc::DOMDocument& d,
               const ::soap::v12::Envelope& x,
               ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Envelope_ (const ::soap::v12::Envelope& x, 
               const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
               ::xml_schema::flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const Envelope&);

    // Serialize to std::ostream.
    //

    void
    Header_ (::std::ostream& os,
             const ::soap::v12::Header& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    void
    Header_ (::std::ostream& os,
             const ::soap::v12::Header& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    void
    Header_ (::std::ostream& os,
             const ::soap::v12::Header& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    Header_ (::xercesc::XMLFormatTarget& ft,
             const ::soap::v12::Header& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    void
    Header_ (::xercesc::XMLFormatTarget& ft,
             const ::soap::v12::Header& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    void
    Header_ (::xercesc::XMLFormatTarget& ft,
             const ::soap::v12::Header& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    Header_ (::xercesc::DOMDocument& d,
             const ::soap::v12::Header& x,
             ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Header_ (const ::soap::v12::Header& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             ::xml_schema::flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const Header&);

    // Serialize to std::ostream.
    //

    void
    Body_ (::std::ostream& os,
           const ::soap::v12::Body& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

    void
    Body_ (::std::ostream& os,
           const ::soap::v12::Body& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

    void
    Body_ (::std::ostream& os,
           const ::soap::v12::Body& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    Body_ (::xercesc::XMLFormatTarget& ft,
           const ::soap::v12::Body& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

    void
    Body_ (::xercesc::XMLFormatTarget& ft,
           const ::soap::v12::Body& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

    void
    Body_ (::xercesc::XMLFormatTarget& ft,
           const ::soap::v12::Body& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::wstring& e = L"UTF-8",
           ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    Body_ (::xercesc::DOMDocument& d,
           const ::soap::v12::Body& x,
           ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Body_ (const ::soap::v12::Body& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const Body&);

    // Serialize to std::ostream.
    //

    void
    Fault_ (::std::ostream& os,
            const ::soap::v12::Fault& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

    void
    Fault_ (::std::ostream& os,
            const ::soap::v12::Fault& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

    void
    Fault_ (::std::ostream& os,
            const ::soap::v12::Fault& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    Fault_ (::xercesc::XMLFormatTarget& ft,
            const ::soap::v12::Fault& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

    void
    Fault_ (::xercesc::XMLFormatTarget& ft,
            const ::soap::v12::Fault& x, 
            ::xml_schema::error_handler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

    void
    Fault_ (::xercesc::XMLFormatTarget& ft,
            const ::soap::v12::Fault& x, 
            ::xercesc::DOMErrorHandler& eh,
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            const ::std::wstring& e = L"UTF-8",
            ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    Fault_ (::xercesc::DOMDocument& d,
            const ::soap::v12::Fault& x,
            ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Fault_ (const ::soap::v12::Fault& x, 
            const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
            ::xml_schema::flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const Fault&);

    void
    operator<< (::xercesc::DOMElement&, const faultreason&);

    void
    operator<< (::xercesc::DOMElement&, const reasontext&);

    void
    operator<< (::xercesc::DOMElement&, const faultcode&);

    void
    operator<< (::xercesc::DOMElement&, const faultcodeEnum&);

    void
    operator<< (::xercesc::DOMAttr&, const faultcodeEnum&);

    void
    operator<< (::xml_schema::list_stream&,
                const faultcodeEnum&);

    void
    operator<< (::xercesc::DOMElement&, const subcode&);

    void
    operator<< (::xercesc::DOMElement&, const detail&);

    // Serialize to std::ostream.
    //

    void
    NotUnderstood (::std::ostream& os,
                   const ::soap::v12::NotUnderstoodType& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

    void
    NotUnderstood (::std::ostream& os,
                   const ::soap::v12::NotUnderstoodType& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

    void
    NotUnderstood (::std::ostream& os,
                   const ::soap::v12::NotUnderstoodType& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    NotUnderstood (::xercesc::XMLFormatTarget& ft,
                   const ::soap::v12::NotUnderstoodType& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

    void
    NotUnderstood (::xercesc::XMLFormatTarget& ft,
                   const ::soap::v12::NotUnderstoodType& x, 
                   ::xml_schema::error_handler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

    void
    NotUnderstood (::xercesc::XMLFormatTarget& ft,
                   const ::soap::v12::NotUnderstoodType& x, 
                   ::xercesc::DOMErrorHandler& eh,
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   const ::std::wstring& e = L"UTF-8",
                   ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    NotUnderstood (::xercesc::DOMDocument& d,
                   const ::soap::v12::NotUnderstoodType& x,
                   ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    NotUnderstood (const ::soap::v12::NotUnderstoodType& x, 
                   const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
                   ::xml_schema::flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const NotUnderstoodType&);

    void
    operator<< (::xercesc::DOMElement&, const SupportedEnvType&);

    // Serialize to std::ostream.
    //

    void
    Upgrade (::std::ostream& os,
             const ::soap::v12::UpgradeType& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    void
    Upgrade (::std::ostream& os,
             const ::soap::v12::UpgradeType& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    void
    Upgrade (::std::ostream& os,
             const ::soap::v12::UpgradeType& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    Upgrade (::xercesc::XMLFormatTarget& ft,
             const ::soap::v12::UpgradeType& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    void
    Upgrade (::xercesc::XMLFormatTarget& ft,
             const ::soap::v12::UpgradeType& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    void
    Upgrade (::xercesc::XMLFormatTarget& ft,
             const ::soap::v12::UpgradeType& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    Upgrade (::xercesc::DOMDocument& d,
             const ::soap::v12::UpgradeType& x,
             ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Upgrade (const ::soap::v12::UpgradeType& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             ::xml_schema::flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const UpgradeType&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_HOME_KAURM_DEV_WORKSPACE_TEMPESOEPROJ_ESOEPROJECT_SAML2CPP_SCHEMA_SOAP_1_2_ENVELOPE_HXX
