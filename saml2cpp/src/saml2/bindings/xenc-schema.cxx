// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License. You may obtain a copy of 
// the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
// License for the specific language governing permissions and limitations under 
// the License.

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "saml2/bindings/xenc-schema.hxx"

namespace w3
{
  namespace xmlenc
  {
    // EncryptedType
    // 

    const EncryptedType::EncryptionMethod_optional& EncryptedType::
    EncryptionMethod () const
    {
      return this->EncryptionMethod_;
    }

    EncryptedType::EncryptionMethod_optional& EncryptedType::
    EncryptionMethod ()
    {
      return this->EncryptionMethod_;
    }

    void EncryptedType::
    EncryptionMethod (const EncryptionMethod_type& x)
    {
      this->EncryptionMethod_.set (x);
    }

    void EncryptedType::
    EncryptionMethod (const EncryptionMethod_optional& x)
    {
      this->EncryptionMethod_ = x;
    }

    void EncryptedType::
    EncryptionMethod (::std::auto_ptr< EncryptionMethod_type > x)
    {
      this->EncryptionMethod_.set (x);
    }

    const EncryptedType::KeyInfo_optional& EncryptedType::
    KeyInfo () const
    {
      return this->KeyInfo_;
    }

    EncryptedType::KeyInfo_optional& EncryptedType::
    KeyInfo ()
    {
      return this->KeyInfo_;
    }

    void EncryptedType::
    KeyInfo (const KeyInfo_type& x)
    {
      this->KeyInfo_.set (x);
    }

    void EncryptedType::
    KeyInfo (const KeyInfo_optional& x)
    {
      this->KeyInfo_ = x;
    }

    void EncryptedType::
    KeyInfo (::std::auto_ptr< KeyInfo_type > x)
    {
      this->KeyInfo_.set (x);
    }

    const EncryptedType::CipherData_type& EncryptedType::
    CipherData () const
    {
      return this->CipherData_.get ();
    }

    EncryptedType::CipherData_type& EncryptedType::
    CipherData ()
    {
      return this->CipherData_.get ();
    }

    void EncryptedType::
    CipherData (const CipherData_type& x)
    {
      this->CipherData_.set (x);
    }

    void EncryptedType::
    CipherData (::std::auto_ptr< CipherData_type > x)
    {
      this->CipherData_.set (x);
    }

    const EncryptedType::EncryptionProperties_optional& EncryptedType::
    EncryptionProperties () const
    {
      return this->EncryptionProperties_;
    }

    EncryptedType::EncryptionProperties_optional& EncryptedType::
    EncryptionProperties ()
    {
      return this->EncryptionProperties_;
    }

    void EncryptedType::
    EncryptionProperties (const EncryptionProperties_type& x)
    {
      this->EncryptionProperties_.set (x);
    }

    void EncryptedType::
    EncryptionProperties (const EncryptionProperties_optional& x)
    {
      this->EncryptionProperties_ = x;
    }

    void EncryptedType::
    EncryptionProperties (::std::auto_ptr< EncryptionProperties_type > x)
    {
      this->EncryptionProperties_.set (x);
    }

    const EncryptedType::Id_optional& EncryptedType::
    Id () const
    {
      return this->Id_;
    }

    EncryptedType::Id_optional& EncryptedType::
    Id ()
    {
      return this->Id_;
    }

    void EncryptedType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void EncryptedType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void EncryptedType::
    Id (::std::auto_ptr< Id_type > x)
    {
      this->Id_.set (x);
    }

    const EncryptedType::Type_optional& EncryptedType::
    Type () const
    {
      return this->Type_;
    }

    EncryptedType::Type_optional& EncryptedType::
    Type ()
    {
      return this->Type_;
    }

    void EncryptedType::
    Type (const Type_type& x)
    {
      this->Type_.set (x);
    }

    void EncryptedType::
    Type (const Type_optional& x)
    {
      this->Type_ = x;
    }

    void EncryptedType::
    Type (::std::auto_ptr< Type_type > x)
    {
      this->Type_.set (x);
    }

    const EncryptedType::MimeType_optional& EncryptedType::
    MimeType () const
    {
      return this->MimeType_;
    }

    EncryptedType::MimeType_optional& EncryptedType::
    MimeType ()
    {
      return this->MimeType_;
    }

    void EncryptedType::
    MimeType (const MimeType_type& x)
    {
      this->MimeType_.set (x);
    }

    void EncryptedType::
    MimeType (const MimeType_optional& x)
    {
      this->MimeType_ = x;
    }

    void EncryptedType::
    MimeType (::std::auto_ptr< MimeType_type > x)
    {
      this->MimeType_.set (x);
    }

    const EncryptedType::Encoding_optional& EncryptedType::
    Encoding () const
    {
      return this->Encoding_;
    }

    EncryptedType::Encoding_optional& EncryptedType::
    Encoding ()
    {
      return this->Encoding_;
    }

    void EncryptedType::
    Encoding (const Encoding_type& x)
    {
      this->Encoding_.set (x);
    }

    void EncryptedType::
    Encoding (const Encoding_optional& x)
    {
      this->Encoding_ = x;
    }

    void EncryptedType::
    Encoding (::std::auto_ptr< Encoding_type > x)
    {
      this->Encoding_.set (x);
    }


    // EncryptionMethodType
    // 

    const EncryptionMethodType::KeySize_optional& EncryptionMethodType::
    KeySize () const
    {
      return this->KeySize_;
    }

    EncryptionMethodType::KeySize_optional& EncryptionMethodType::
    KeySize ()
    {
      return this->KeySize_;
    }

    void EncryptionMethodType::
    KeySize (const KeySize_type& x)
    {
      this->KeySize_.set (x);
    }

    void EncryptionMethodType::
    KeySize (const KeySize_optional& x)
    {
      this->KeySize_ = x;
    }

    void EncryptionMethodType::
    KeySize (::std::auto_ptr< KeySize_type > x)
    {
      this->KeySize_.set (x);
    }

    const EncryptionMethodType::OAEPparams_optional& EncryptionMethodType::
    OAEPparams () const
    {
      return this->OAEPparams_;
    }

    EncryptionMethodType::OAEPparams_optional& EncryptionMethodType::
    OAEPparams ()
    {
      return this->OAEPparams_;
    }

    void EncryptionMethodType::
    OAEPparams (const OAEPparams_type& x)
    {
      this->OAEPparams_.set (x);
    }

    void EncryptionMethodType::
    OAEPparams (const OAEPparams_optional& x)
    {
      this->OAEPparams_ = x;
    }

    void EncryptionMethodType::
    OAEPparams (::std::auto_ptr< OAEPparams_type > x)
    {
      this->OAEPparams_.set (x);
    }

    const EncryptionMethodType::any_sequence& EncryptionMethodType::
    any () const
    {
      return this->any_;
    }

    EncryptionMethodType::any_sequence& EncryptionMethodType::
    any ()
    {
      return this->any_;
    }

    void EncryptionMethodType::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const EncryptionMethodType::Algorithm_type& EncryptionMethodType::
    Algorithm () const
    {
      return this->Algorithm_.get ();
    }

    EncryptionMethodType::Algorithm_type& EncryptionMethodType::
    Algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void EncryptionMethodType::
    Algorithm (const Algorithm_type& x)
    {
      this->Algorithm_.set (x);
    }

    void EncryptionMethodType::
    Algorithm (::std::auto_ptr< Algorithm_type > x)
    {
      this->Algorithm_.set (x);
    }

    const ::xercesc::DOMDocument& EncryptionMethodType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& EncryptionMethodType::
    dom_document ()
    {
      return *dom_document_;
    }


    // KeySizeType
    // 


    // CipherDataType
    // 

    const CipherDataType::CipherValue_optional& CipherDataType::
    CipherValue () const
    {
      return this->CipherValue_;
    }

    CipherDataType::CipherValue_optional& CipherDataType::
    CipherValue ()
    {
      return this->CipherValue_;
    }

    void CipherDataType::
    CipherValue (const CipherValue_type& x)
    {
      this->CipherValue_.set (x);
    }

    void CipherDataType::
    CipherValue (const CipherValue_optional& x)
    {
      this->CipherValue_ = x;
    }

    void CipherDataType::
    CipherValue (::std::auto_ptr< CipherValue_type > x)
    {
      this->CipherValue_.set (x);
    }

    const CipherDataType::CipherReference_optional& CipherDataType::
    CipherReference () const
    {
      return this->CipherReference_;
    }

    CipherDataType::CipherReference_optional& CipherDataType::
    CipherReference ()
    {
      return this->CipherReference_;
    }

    void CipherDataType::
    CipherReference (const CipherReference_type& x)
    {
      this->CipherReference_.set (x);
    }

    void CipherDataType::
    CipherReference (const CipherReference_optional& x)
    {
      this->CipherReference_ = x;
    }

    void CipherDataType::
    CipherReference (::std::auto_ptr< CipherReference_type > x)
    {
      this->CipherReference_.set (x);
    }


    // CipherReferenceType
    // 

    const CipherReferenceType::Transforms_optional& CipherReferenceType::
    Transforms () const
    {
      return this->Transforms_;
    }

    CipherReferenceType::Transforms_optional& CipherReferenceType::
    Transforms ()
    {
      return this->Transforms_;
    }

    void CipherReferenceType::
    Transforms (const Transforms_type& x)
    {
      this->Transforms_.set (x);
    }

    void CipherReferenceType::
    Transforms (const Transforms_optional& x)
    {
      this->Transforms_ = x;
    }

    void CipherReferenceType::
    Transforms (::std::auto_ptr< Transforms_type > x)
    {
      this->Transforms_.set (x);
    }

    const CipherReferenceType::URI_type& CipherReferenceType::
    URI () const
    {
      return this->URI_.get ();
    }

    CipherReferenceType::URI_type& CipherReferenceType::
    URI ()
    {
      return this->URI_.get ();
    }

    void CipherReferenceType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void CipherReferenceType::
    URI (::std::auto_ptr< URI_type > x)
    {
      this->URI_.set (x);
    }


    // TransformsType
    // 

    const TransformsType::Transform_sequence& TransformsType::
    Transform () const
    {
      return this->Transform_;
    }

    TransformsType::Transform_sequence& TransformsType::
    Transform ()
    {
      return this->Transform_;
    }

    void TransformsType::
    Transform (const Transform_sequence& s)
    {
      this->Transform_ = s;
    }


    // EncryptedDataType
    // 


    // EncryptedKeyType
    // 

    const EncryptedKeyType::ReferenceList_optional& EncryptedKeyType::
    ReferenceList () const
    {
      return this->ReferenceList_;
    }

    EncryptedKeyType::ReferenceList_optional& EncryptedKeyType::
    ReferenceList ()
    {
      return this->ReferenceList_;
    }

    void EncryptedKeyType::
    ReferenceList (const ReferenceList_type& x)
    {
      this->ReferenceList_.set (x);
    }

    void EncryptedKeyType::
    ReferenceList (const ReferenceList_optional& x)
    {
      this->ReferenceList_ = x;
    }

    void EncryptedKeyType::
    ReferenceList (::std::auto_ptr< ReferenceList_type > x)
    {
      this->ReferenceList_.set (x);
    }

    const EncryptedKeyType::CarriedKeyName_optional& EncryptedKeyType::
    CarriedKeyName () const
    {
      return this->CarriedKeyName_;
    }

    EncryptedKeyType::CarriedKeyName_optional& EncryptedKeyType::
    CarriedKeyName ()
    {
      return this->CarriedKeyName_;
    }

    void EncryptedKeyType::
    CarriedKeyName (const CarriedKeyName_type& x)
    {
      this->CarriedKeyName_.set (x);
    }

    void EncryptedKeyType::
    CarriedKeyName (const CarriedKeyName_optional& x)
    {
      this->CarriedKeyName_ = x;
    }

    void EncryptedKeyType::
    CarriedKeyName (::std::auto_ptr< CarriedKeyName_type > x)
    {
      this->CarriedKeyName_.set (x);
    }

    const EncryptedKeyType::Recipient_optional& EncryptedKeyType::
    Recipient () const
    {
      return this->Recipient_;
    }

    EncryptedKeyType::Recipient_optional& EncryptedKeyType::
    Recipient ()
    {
      return this->Recipient_;
    }

    void EncryptedKeyType::
    Recipient (const Recipient_type& x)
    {
      this->Recipient_.set (x);
    }

    void EncryptedKeyType::
    Recipient (const Recipient_optional& x)
    {
      this->Recipient_ = x;
    }

    void EncryptedKeyType::
    Recipient (::std::auto_ptr< Recipient_type > x)
    {
      this->Recipient_.set (x);
    }


    // AgreementMethodType
    // 

    const AgreementMethodType::KA_Nonce_optional& AgreementMethodType::
    KA_Nonce () const
    {
      return this->KA_Nonce_;
    }

    AgreementMethodType::KA_Nonce_optional& AgreementMethodType::
    KA_Nonce ()
    {
      return this->KA_Nonce_;
    }

    void AgreementMethodType::
    KA_Nonce (const KA_Nonce_type& x)
    {
      this->KA_Nonce_.set (x);
    }

    void AgreementMethodType::
    KA_Nonce (const KA_Nonce_optional& x)
    {
      this->KA_Nonce_ = x;
    }

    void AgreementMethodType::
    KA_Nonce (::std::auto_ptr< KA_Nonce_type > x)
    {
      this->KA_Nonce_.set (x);
    }

    const AgreementMethodType::any_sequence& AgreementMethodType::
    any () const
    {
      return this->any_;
    }

    AgreementMethodType::any_sequence& AgreementMethodType::
    any ()
    {
      return this->any_;
    }

    void AgreementMethodType::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const AgreementMethodType::OriginatorKeyInfo_optional& AgreementMethodType::
    OriginatorKeyInfo () const
    {
      return this->OriginatorKeyInfo_;
    }

    AgreementMethodType::OriginatorKeyInfo_optional& AgreementMethodType::
    OriginatorKeyInfo ()
    {
      return this->OriginatorKeyInfo_;
    }

    void AgreementMethodType::
    OriginatorKeyInfo (const OriginatorKeyInfo_type& x)
    {
      this->OriginatorKeyInfo_.set (x);
    }

    void AgreementMethodType::
    OriginatorKeyInfo (const OriginatorKeyInfo_optional& x)
    {
      this->OriginatorKeyInfo_ = x;
    }

    void AgreementMethodType::
    OriginatorKeyInfo (::std::auto_ptr< OriginatorKeyInfo_type > x)
    {
      this->OriginatorKeyInfo_.set (x);
    }

    const AgreementMethodType::RecipientKeyInfo_optional& AgreementMethodType::
    RecipientKeyInfo () const
    {
      return this->RecipientKeyInfo_;
    }

    AgreementMethodType::RecipientKeyInfo_optional& AgreementMethodType::
    RecipientKeyInfo ()
    {
      return this->RecipientKeyInfo_;
    }

    void AgreementMethodType::
    RecipientKeyInfo (const RecipientKeyInfo_type& x)
    {
      this->RecipientKeyInfo_.set (x);
    }

    void AgreementMethodType::
    RecipientKeyInfo (const RecipientKeyInfo_optional& x)
    {
      this->RecipientKeyInfo_ = x;
    }

    void AgreementMethodType::
    RecipientKeyInfo (::std::auto_ptr< RecipientKeyInfo_type > x)
    {
      this->RecipientKeyInfo_.set (x);
    }

    const AgreementMethodType::Algorithm_type& AgreementMethodType::
    Algorithm () const
    {
      return this->Algorithm_.get ();
    }

    AgreementMethodType::Algorithm_type& AgreementMethodType::
    Algorithm ()
    {
      return this->Algorithm_.get ();
    }

    void AgreementMethodType::
    Algorithm (const Algorithm_type& x)
    {
      this->Algorithm_.set (x);
    }

    void AgreementMethodType::
    Algorithm (::std::auto_ptr< Algorithm_type > x)
    {
      this->Algorithm_.set (x);
    }

    const ::xercesc::DOMDocument& AgreementMethodType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& AgreementMethodType::
    dom_document ()
    {
      return *dom_document_;
    }


    // ReferenceType
    // 

    const ReferenceType::any_sequence& ReferenceType::
    any () const
    {
      return this->any_;
    }

    ReferenceType::any_sequence& ReferenceType::
    any ()
    {
      return this->any_;
    }

    void ReferenceType::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const ReferenceType::URI_type& ReferenceType::
    URI () const
    {
      return this->URI_.get ();
    }

    ReferenceType::URI_type& ReferenceType::
    URI ()
    {
      return this->URI_.get ();
    }

    void ReferenceType::
    URI (const URI_type& x)
    {
      this->URI_.set (x);
    }

    void ReferenceType::
    URI (::std::auto_ptr< URI_type > x)
    {
      this->URI_.set (x);
    }

    const ::xercesc::DOMDocument& ReferenceType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& ReferenceType::
    dom_document ()
    {
      return *dom_document_;
    }


    // EncryptionPropertiesType
    // 

    const EncryptionPropertiesType::EncryptionProperty_sequence& EncryptionPropertiesType::
    EncryptionProperty () const
    {
      return this->EncryptionProperty_;
    }

    EncryptionPropertiesType::EncryptionProperty_sequence& EncryptionPropertiesType::
    EncryptionProperty ()
    {
      return this->EncryptionProperty_;
    }

    void EncryptionPropertiesType::
    EncryptionProperty (const EncryptionProperty_sequence& s)
    {
      this->EncryptionProperty_ = s;
    }

    const EncryptionPropertiesType::Id_optional& EncryptionPropertiesType::
    Id () const
    {
      return this->Id_;
    }

    EncryptionPropertiesType::Id_optional& EncryptionPropertiesType::
    Id ()
    {
      return this->Id_;
    }

    void EncryptionPropertiesType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void EncryptionPropertiesType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void EncryptionPropertiesType::
    Id (::std::auto_ptr< Id_type > x)
    {
      this->Id_.set (x);
    }


    // EncryptionPropertyType
    // 

    const EncryptionPropertyType::any_sequence& EncryptionPropertyType::
    any () const
    {
      return this->any_;
    }

    EncryptionPropertyType::any_sequence& EncryptionPropertyType::
    any ()
    {
      return this->any_;
    }

    void EncryptionPropertyType::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const EncryptionPropertyType::Target_optional& EncryptionPropertyType::
    Target () const
    {
      return this->Target_;
    }

    EncryptionPropertyType::Target_optional& EncryptionPropertyType::
    Target ()
    {
      return this->Target_;
    }

    void EncryptionPropertyType::
    Target (const Target_type& x)
    {
      this->Target_.set (x);
    }

    void EncryptionPropertyType::
    Target (const Target_optional& x)
    {
      this->Target_ = x;
    }

    void EncryptionPropertyType::
    Target (::std::auto_ptr< Target_type > x)
    {
      this->Target_.set (x);
    }

    const EncryptionPropertyType::Id_optional& EncryptionPropertyType::
    Id () const
    {
      return this->Id_;
    }

    EncryptionPropertyType::Id_optional& EncryptionPropertyType::
    Id ()
    {
      return this->Id_;
    }

    void EncryptionPropertyType::
    Id (const Id_type& x)
    {
      this->Id_.set (x);
    }

    void EncryptionPropertyType::
    Id (const Id_optional& x)
    {
      this->Id_ = x;
    }

    void EncryptionPropertyType::
    Id (::std::auto_ptr< Id_type > x)
    {
      this->Id_.set (x);
    }

    const EncryptionPropertyType::any_attribute_set& EncryptionPropertyType::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    EncryptionPropertyType::any_attribute_set& EncryptionPropertyType::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void EncryptionPropertyType::
    any_attribute (const any_attribute_set& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& EncryptionPropertyType::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& EncryptionPropertyType::
    dom_document ()
    {
      return *dom_document_;
    }


    // ReferenceList
    // 

    const ReferenceList::DataReference_sequence& ReferenceList::
    DataReference () const
    {
      return this->DataReference_;
    }

    ReferenceList::DataReference_sequence& ReferenceList::
    DataReference ()
    {
      return this->DataReference_;
    }

    void ReferenceList::
    DataReference (const DataReference_sequence& s)
    {
      this->DataReference_ = s;
    }

    const ReferenceList::KeyReference_sequence& ReferenceList::
    KeyReference () const
    {
      return this->KeyReference_;
    }

    ReferenceList::KeyReference_sequence& ReferenceList::
    KeyReference ()
    {
      return this->KeyReference_;
    }

    void ReferenceList::
    KeyReference (const KeyReference_sequence& s)
    {
      this->KeyReference_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace w3
{
  namespace xmlenc
  {
    // EncryptedType
    //

    EncryptedType::
    EncryptedType ()
    : ::xml_schema::type (),
      EncryptionMethod_ (::xml_schema::flags (), this),
      KeyInfo_ (::xml_schema::flags (), this),
      CipherData_ (::xml_schema::flags (), this),
      EncryptionProperties_ (::xml_schema::flags (), this),
      Id_ (::xml_schema::flags (), this),
      Type_ (::xml_schema::flags (), this),
      MimeType_ (::xml_schema::flags (), this),
      Encoding_ (::xml_schema::flags (), this)
    {
    }

    EncryptedType::
    EncryptedType (const CipherData_type& CipherData)
    : ::xml_schema::type (),
      EncryptionMethod_ (::xml_schema::flags (), this),
      KeyInfo_ (::xml_schema::flags (), this),
      CipherData_ (CipherData, ::xml_schema::flags (), this),
      EncryptionProperties_ (::xml_schema::flags (), this),
      Id_ (::xml_schema::flags (), this),
      Type_ (::xml_schema::flags (), this),
      MimeType_ (::xml_schema::flags (), this),
      Encoding_ (::xml_schema::flags (), this)
    {
    }

    EncryptedType::
    EncryptedType (::std::auto_ptr< CipherData_type >& CipherData)
    : ::xml_schema::type (),
      EncryptionMethod_ (::xml_schema::flags (), this),
      KeyInfo_ (::xml_schema::flags (), this),
      CipherData_ (CipherData, ::xml_schema::flags (), this),
      EncryptionProperties_ (::xml_schema::flags (), this),
      Id_ (::xml_schema::flags (), this),
      Type_ (::xml_schema::flags (), this),
      MimeType_ (::xml_schema::flags (), this),
      Encoding_ (::xml_schema::flags (), this)
    {
    }

    EncryptedType::
    EncryptedType (const EncryptedType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EncryptionMethod_ (x.EncryptionMethod_, f, this),
      KeyInfo_ (x.KeyInfo_, f, this),
      CipherData_ (x.CipherData_, f, this),
      EncryptionProperties_ (x.EncryptionProperties_, f, this),
      Id_ (x.Id_, f, this),
      Type_ (x.Type_, f, this),
      MimeType_ (x.MimeType_, f, this),
      Encoding_ (x.Encoding_, f, this)
    {
    }

    EncryptedType::
    EncryptedType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EncryptionMethod_ (f, this),
      KeyInfo_ (f, this),
      CipherData_ (f, this),
      EncryptionProperties_ (f, this),
      Id_ (f, this),
      Type_ (f, this),
      MimeType_ (f, this),
      Encoding_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EncryptedType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EncryptionMethod
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"EncryptionMethod",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< EncryptionMethod_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->EncryptionMethod_)
            {
              ::std::auto_ptr< EncryptionMethod_type > r (
                dynamic_cast< EncryptionMethod_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EncryptionMethod_.set (r);
              continue;
            }
          }
        }

        // KeyInfo
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"KeyInfo",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< KeyInfo_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->KeyInfo_)
            {
              ::std::auto_ptr< KeyInfo_type > r (
                dynamic_cast< KeyInfo_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->KeyInfo_.set (r);
              continue;
            }
          }
        }

        // CipherData
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"CipherData",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< CipherData_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!CipherData_.present ())
            {
              ::std::auto_ptr< CipherData_type > r (
                dynamic_cast< CipherData_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CipherData_.set (r);
              continue;
            }
          }
        }

        // EncryptionProperties
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"EncryptionProperties",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< EncryptionProperties_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->EncryptionProperties_)
            {
              ::std::auto_ptr< EncryptionProperties_type > r (
                dynamic_cast< EncryptionProperties_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->EncryptionProperties_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!CipherData_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"CipherData",
          L"http://www.w3.org/2001/04/xmlenc#");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }

        if (n.name () == L"Type" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Type_type > r (
            Type_traits::create (i, f, this));

          this->Type_.set (r);
          continue;
        }

        if (n.name () == L"MimeType" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< MimeType_type > r (
            MimeType_traits::create (i, f, this));

          this->MimeType_.set (r);
          continue;
        }

        if (n.name () == L"Encoding" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Encoding_type > r (
            Encoding_traits::create (i, f, this));

          this->Encoding_.set (r);
          continue;
        }
      }
    }

    EncryptedType* EncryptedType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EncryptedType (*this, f, c);
    }

    EncryptedType::
    ~EncryptedType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EncryptedType >
    _xsd_EncryptedType_type_factory_init (
      L"EncryptedType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // EncryptionMethodType
    //

    EncryptionMethodType::
    EncryptionMethodType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      KeySize_ (::xml_schema::flags (), this),
      OAEPparams_ (::xml_schema::flags (), this),
      any_ (this->dom_document ()),
      Algorithm_ (::xml_schema::flags (), this)
    {
    }

    EncryptionMethodType::
    EncryptionMethodType (const Algorithm_type& Algorithm)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      KeySize_ (::xml_schema::flags (), this),
      OAEPparams_ (::xml_schema::flags (), this),
      any_ (this->dom_document ()),
      Algorithm_ (Algorithm, ::xml_schema::flags (), this)
    {
    }

    EncryptionMethodType::
    EncryptionMethodType (const EncryptionMethodType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      KeySize_ (x.KeySize_, f, this),
      OAEPparams_ (x.OAEPparams_, f, this),
      any_ (x.any_, this->dom_document ()),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    EncryptionMethodType::
    EncryptionMethodType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      KeySize_ (f, this),
      OAEPparams_ (f, this),
      any_ (this->dom_document ()),
      Algorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EncryptionMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // KeySize
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"KeySize",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< KeySize_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->KeySize_)
            {
              ::std::auto_ptr< KeySize_type > r (
                dynamic_cast< KeySize_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->KeySize_.set (r);
              continue;
            }
          }
        }

        // OAEPparams
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"OAEPparams",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< OAEPparams_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->OAEPparams_)
            {
              ::std::auto_ptr< OAEPparams_type > r (
                dynamic_cast< OAEPparams_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->OAEPparams_.set (r);
              continue;
            }
          }
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"http://www.w3.org/2001/04/xmlenc#"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Algorithm" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Algorithm_type > r (
            Algorithm_traits::create (i, f, this));

          this->Algorithm_.set (r);
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Algorithm",
          L"");
      }
    }

    EncryptionMethodType* EncryptionMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EncryptionMethodType (*this, f, c);
    }

    EncryptionMethodType::
    ~EncryptionMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EncryptionMethodType >
    _xsd_EncryptionMethodType_type_factory_init (
      L"EncryptionMethodType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // KeySizeType
    //

    KeySizeType::
    KeySizeType ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > ()
    {
    }

    KeySizeType::
    KeySizeType (const ::xml_schema::integer& _xsd_integer_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (_xsd_integer_base)
    {
    }

    KeySizeType::
    KeySizeType (const KeySizeType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (x, f, c)
    {
    }

    KeySizeType::
    KeySizeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (e, f, c)
    {
    }

    KeySizeType::
    KeySizeType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (a, f, c)
    {
    }

    KeySizeType::
    KeySizeType (const ::std::wstring& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    KeySizeType* KeySizeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class KeySizeType (*this, f, c);
    }

    KeySizeType::
    ~KeySizeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, KeySizeType >
    _xsd_KeySizeType_type_factory_init (
      L"KeySizeType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // CipherDataType
    //

    CipherDataType::
    CipherDataType ()
    : ::xml_schema::type (),
      CipherValue_ (::xml_schema::flags (), this),
      CipherReference_ (::xml_schema::flags (), this)
    {
    }

    CipherDataType::
    CipherDataType (const CipherDataType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      CipherValue_ (x.CipherValue_, f, this),
      CipherReference_ (x.CipherReference_, f, this)
    {
    }

    CipherDataType::
    CipherDataType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      CipherValue_ (f, this),
      CipherReference_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void CipherDataType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // CipherValue
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"CipherValue",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< CipherValue_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->CipherValue_)
            {
              ::std::auto_ptr< CipherValue_type > r (
                dynamic_cast< CipherValue_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CipherValue_.set (r);
              continue;
            }
          }
        }

        // CipherReference
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"CipherReference",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< CipherReference_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->CipherReference_)
            {
              ::std::auto_ptr< CipherReference_type > r (
                dynamic_cast< CipherReference_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CipherReference_.set (r);
              continue;
            }
          }
        }

        break;
      }
    }

    CipherDataType* CipherDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CipherDataType (*this, f, c);
    }

    CipherDataType::
    ~CipherDataType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CipherDataType >
    _xsd_CipherDataType_type_factory_init (
      L"CipherDataType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // CipherReferenceType
    //

    CipherReferenceType::
    CipherReferenceType ()
    : ::xml_schema::type (),
      Transforms_ (::xml_schema::flags (), this),
      URI_ (::xml_schema::flags (), this)
    {
    }

    CipherReferenceType::
    CipherReferenceType (const URI_type& URI)
    : ::xml_schema::type (),
      Transforms_ (::xml_schema::flags (), this),
      URI_ (URI, ::xml_schema::flags (), this)
    {
    }

    CipherReferenceType::
    CipherReferenceType (const CipherReferenceType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Transforms_ (x.Transforms_, f, this),
      URI_ (x.URI_, f, this)
    {
    }

    CipherReferenceType::
    CipherReferenceType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Transforms_ (f, this),
      URI_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void CipherReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Transforms
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Transforms",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< Transforms_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Transforms_)
            {
              ::std::auto_ptr< Transforms_type > r (
                dynamic_cast< Transforms_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Transforms_.set (r);
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URI_type > r (
            URI_traits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }
      }

      if (!URI_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"URI",
          L"");
      }
    }

    CipherReferenceType* CipherReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class CipherReferenceType (*this, f, c);
    }

    CipherReferenceType::
    ~CipherReferenceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, CipherReferenceType >
    _xsd_CipherReferenceType_type_factory_init (
      L"CipherReferenceType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // TransformsType
    //

    TransformsType::
    TransformsType ()
    : ::xml_schema::type (),
      Transform_ (::xml_schema::flags (), this)
    {
    }

    TransformsType::
    TransformsType (const TransformsType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Transform_ (x.Transform_, f, this)
    {
    }

    TransformsType::
    TransformsType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Transform_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void TransformsType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Transform
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Transform",
              L"http://www.w3.org/2000/09/xmldsig#",
              &::xsd::cxx::tree::factory_impl< Transform_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Transform_type > r (
              dynamic_cast< Transform_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Transform_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    TransformsType* TransformsType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class TransformsType (*this, f, c);
    }

    TransformsType::
    ~TransformsType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, TransformsType >
    _xsd_TransformsType_type_factory_init (
      L"TransformsType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // EncryptedDataType
    //

    EncryptedDataType::
    EncryptedDataType ()
    : ::w3::xmlenc::EncryptedType ()
    {
    }

    EncryptedDataType::
    EncryptedDataType (const CipherData_type& CipherData)
    : ::w3::xmlenc::EncryptedType (CipherData)
    {
    }

    EncryptedDataType::
    EncryptedDataType (::std::auto_ptr< CipherData_type >& CipherData)
    : ::w3::xmlenc::EncryptedType (CipherData)
    {
    }

    EncryptedDataType::
    EncryptedDataType (const EncryptedDataType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::w3::xmlenc::EncryptedType (x, f, c)
    {
    }

    EncryptedDataType::
    EncryptedDataType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::w3::xmlenc::EncryptedType (e, f, c)
    {
    }

    EncryptedDataType* EncryptedDataType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EncryptedDataType (*this, f, c);
    }

    EncryptedDataType::
    ~EncryptedDataType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EncryptedDataType >
    _xsd_EncryptedDataType_type_factory_init (
      L"EncryptedDataType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // EncryptedKeyType
    //

    EncryptedKeyType::
    EncryptedKeyType ()
    : ::w3::xmlenc::EncryptedType (),
      ReferenceList_ (::xml_schema::flags (), this),
      CarriedKeyName_ (::xml_schema::flags (), this),
      Recipient_ (::xml_schema::flags (), this)
    {
    }

    EncryptedKeyType::
    EncryptedKeyType (const CipherData_type& CipherData)
    : ::w3::xmlenc::EncryptedType (CipherData),
      ReferenceList_ (::xml_schema::flags (), this),
      CarriedKeyName_ (::xml_schema::flags (), this),
      Recipient_ (::xml_schema::flags (), this)
    {
    }

    EncryptedKeyType::
    EncryptedKeyType (::std::auto_ptr< CipherData_type >& CipherData)
    : ::w3::xmlenc::EncryptedType (CipherData),
      ReferenceList_ (::xml_schema::flags (), this),
      CarriedKeyName_ (::xml_schema::flags (), this),
      Recipient_ (::xml_schema::flags (), this)
    {
    }

    EncryptedKeyType::
    EncryptedKeyType (const EncryptedKeyType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::w3::xmlenc::EncryptedType (x, f, c),
      ReferenceList_ (x.ReferenceList_, f, this),
      CarriedKeyName_ (x.CarriedKeyName_, f, this),
      Recipient_ (x.Recipient_, f, this)
    {
    }

    EncryptedKeyType::
    EncryptedKeyType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::w3::xmlenc::EncryptedType (e, f | ::xml_schema::flags::base, c),
      ReferenceList_ (f, this),
      CarriedKeyName_ (f, this),
      Recipient_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EncryptedKeyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      this->::w3::xmlenc::EncryptedType::parse (p, f);

      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ReferenceList
        //
        if (n.name () == L"ReferenceList" && n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
        {
          ::std::auto_ptr< ReferenceList_type > r (
            ReferenceList_traits::create (i, f, this));

          if (!this->ReferenceList_)
          {
            this->ReferenceList_.set (r);
            continue;
          }
        }

        // CarriedKeyName
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"CarriedKeyName",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< CarriedKeyName_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->CarriedKeyName_)
            {
              ::std::auto_ptr< CarriedKeyName_type > r (
                dynamic_cast< CarriedKeyName_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->CarriedKeyName_.set (r);
              continue;
            }
          }
        }

        break;
      }

      p.reset_attributes ();

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Recipient" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Recipient_type > r (
            Recipient_traits::create (i, f, this));

          this->Recipient_.set (r);
          continue;
        }
      }
    }

    EncryptedKeyType* EncryptedKeyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EncryptedKeyType (*this, f, c);
    }

    EncryptedKeyType::
    ~EncryptedKeyType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EncryptedKeyType >
    _xsd_EncryptedKeyType_type_factory_init (
      L"EncryptedKeyType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // AgreementMethodType
    //

    AgreementMethodType::
    AgreementMethodType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      KA_Nonce_ (::xml_schema::flags (), this),
      any_ (this->dom_document ()),
      OriginatorKeyInfo_ (::xml_schema::flags (), this),
      RecipientKeyInfo_ (::xml_schema::flags (), this),
      Algorithm_ (::xml_schema::flags (), this)
    {
    }

    AgreementMethodType::
    AgreementMethodType (const Algorithm_type& Algorithm)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      KA_Nonce_ (::xml_schema::flags (), this),
      any_ (this->dom_document ()),
      OriginatorKeyInfo_ (::xml_schema::flags (), this),
      RecipientKeyInfo_ (::xml_schema::flags (), this),
      Algorithm_ (Algorithm, ::xml_schema::flags (), this)
    {
    }

    AgreementMethodType::
    AgreementMethodType (const AgreementMethodType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      KA_Nonce_ (x.KA_Nonce_, f, this),
      any_ (x.any_, this->dom_document ()),
      OriginatorKeyInfo_ (x.OriginatorKeyInfo_, f, this),
      RecipientKeyInfo_ (x.RecipientKeyInfo_, f, this),
      Algorithm_ (x.Algorithm_, f, this)
    {
    }

    AgreementMethodType::
    AgreementMethodType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      KA_Nonce_ (f, this),
      any_ (this->dom_document ()),
      OriginatorKeyInfo_ (f, this),
      RecipientKeyInfo_ (f, this),
      Algorithm_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void AgreementMethodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // KA-Nonce
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"KA-Nonce",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< KA_Nonce_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->KA_Nonce_)
            {
              ::std::auto_ptr< KA_Nonce_type > r (
                dynamic_cast< KA_Nonce_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->KA_Nonce_.set (r);
              continue;
            }
          }
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"http://www.w3.org/2001/04/xmlenc#"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        // OriginatorKeyInfo
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"OriginatorKeyInfo",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< OriginatorKeyInfo_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->OriginatorKeyInfo_)
            {
              ::std::auto_ptr< OriginatorKeyInfo_type > r (
                dynamic_cast< OriginatorKeyInfo_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->OriginatorKeyInfo_.set (r);
              continue;
            }
          }
        }

        // RecipientKeyInfo
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"RecipientKeyInfo",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< RecipientKeyInfo_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->RecipientKeyInfo_)
            {
              ::std::auto_ptr< RecipientKeyInfo_type > r (
                dynamic_cast< RecipientKeyInfo_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->RecipientKeyInfo_.set (r);
              continue;
            }
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Algorithm" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Algorithm_type > r (
            Algorithm_traits::create (i, f, this));

          this->Algorithm_.set (r);
          continue;
        }
      }

      if (!Algorithm_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"Algorithm",
          L"");
      }
    }

    AgreementMethodType* AgreementMethodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class AgreementMethodType (*this, f, c);
    }

    AgreementMethodType::
    ~AgreementMethodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, AgreementMethodType >
    _xsd_AgreementMethodType_type_factory_init (
      L"AgreementMethodType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // ReferenceType
    //

    ReferenceType::
    ReferenceType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      URI_ (::xml_schema::flags (), this)
    {
    }

    ReferenceType::
    ReferenceType (const URI_type& URI)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      URI_ (URI, ::xml_schema::flags (), this)
    {
    }

    ReferenceType::
    ReferenceType (const ReferenceType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      URI_ (x.URI_, f, this)
    {
    }

    ReferenceType::
    ReferenceType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      URI_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void ReferenceType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"http://www.w3.org/2001/04/xmlenc#"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"URI" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< URI_type > r (
            URI_traits::create (i, f, this));

          this->URI_.set (r);
          continue;
        }
      }

      if (!URI_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"URI",
          L"");
      }
    }

    ReferenceType* ReferenceType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReferenceType (*this, f, c);
    }

    ReferenceType::
    ~ReferenceType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, ReferenceType >
    _xsd_ReferenceType_type_factory_init (
      L"ReferenceType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // EncryptionPropertiesType
    //

    EncryptionPropertiesType::
    EncryptionPropertiesType ()
    : ::xml_schema::type (),
      EncryptionProperty_ (::xml_schema::flags (), this),
      Id_ (::xml_schema::flags (), this)
    {
    }

    EncryptionPropertiesType::
    EncryptionPropertiesType (const EncryptionPropertiesType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      EncryptionProperty_ (x.EncryptionProperty_, f, this),
      Id_ (x.Id_, f, this)
    {
    }

    EncryptionPropertiesType::
    EncryptionPropertiesType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      EncryptionProperty_ (f, this),
      Id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EncryptionPropertiesType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // EncryptionProperty
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"EncryptionProperty",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< EncryptionProperty_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< EncryptionProperty_type > r (
              dynamic_cast< EncryptionProperty_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->EncryptionProperty_.push_back (r);
            continue;
          }
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }
      }
    }

    EncryptionPropertiesType* EncryptionPropertiesType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EncryptionPropertiesType (*this, f, c);
    }

    EncryptionPropertiesType::
    ~EncryptionPropertiesType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EncryptionPropertiesType >
    _xsd_EncryptionPropertiesType_type_factory_init (
      L"EncryptionPropertiesType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // EncryptionPropertyType
    //

    EncryptionPropertyType::
    EncryptionPropertyType ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      Target_ (::xml_schema::flags (), this),
      Id_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    EncryptionPropertyType::
    EncryptionPropertyType (const EncryptionPropertyType& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      Target_ (x.Target_, f, this),
      Id_ (x.Id_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    EncryptionPropertyType::
    EncryptionPropertyType (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      Target_ (f, this),
      Id_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void EncryptionPropertyType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"http://www.w3.org/2001/04/xmlenc#"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"Target" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Target_type > r (
            Target_traits::create (i, f, this));

          this->Target_.set (r);
          continue;
        }

        if (n.name () == L"Id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< Id_type > r (
            Id_traits::create (i, f, this));

          this->Id_.set (r);
          continue;
        }

        // any_attribute
        //
        if (n.namespace_ () == L"http://www.w3.org/XML/1998/namespace")
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    EncryptionPropertyType* EncryptionPropertyType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class EncryptionPropertyType (*this, f, c);
    }

    EncryptionPropertyType::
    ~EncryptionPropertyType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, EncryptionPropertyType >
    _xsd_EncryptionPropertyType_type_factory_init (
      L"EncryptionPropertyType",
      L"http://www.w3.org/2001/04/xmlenc#");

    // ReferenceList
    //

    ReferenceList::
    ReferenceList ()
    : ::xml_schema::type (),
      DataReference_ (::xml_schema::flags (), this),
      KeyReference_ (::xml_schema::flags (), this)
    {
    }

    ReferenceList::
    ReferenceList (const ReferenceList& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      DataReference_ (x.DataReference_, f, this),
      KeyReference_ (x.KeyReference_, f, this)
    {
    }

    ReferenceList::
    ReferenceList (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      DataReference_ (f, this),
      KeyReference_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ReferenceList::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // DataReference
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"DataReference",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< DataReference_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< DataReference_type > r (
              dynamic_cast< DataReference_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->DataReference_.push_back (r);
            continue;
          }
        }

        // KeyReference
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"KeyReference",
              L"http://www.w3.org/2001/04/xmlenc#",
              &::xsd::cxx::tree::factory_impl< KeyReference_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< KeyReference_type > r (
              dynamic_cast< KeyReference_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->KeyReference_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    ReferenceList* ReferenceList::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ReferenceList (*this, f, c);
    }

    ReferenceList::
    ~ReferenceList ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace w3
{
  namespace xmlenc
  {
    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (const ::std::wstring& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherDataType > r (
        ::w3::xmlenc::CipherData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (const ::std::wstring& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherDataType > r (
        ::w3::xmlenc::CipherData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (const ::std::wstring& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherDataType > r (
        ::w3::xmlenc::CipherData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::CipherData (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::CipherData (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::CipherData (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::CipherData (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::std::istream& is,
                const ::std::wstring& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::CipherData (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::std::istream& is,
                const ::std::wstring& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::CipherData (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherDataType > r (
        ::w3::xmlenc::CipherData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherDataType > r (
        ::w3::xmlenc::CipherData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherDataType > r (
        ::w3::xmlenc::CipherData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::w3::xmlenc::CipherDataType > r (
          ::w3::xmlenc::CipherData (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"CipherData",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::CipherDataType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::w3::xmlenc::CipherDataType > r (
          dynamic_cast< ::w3::xmlenc::CipherDataType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"CipherData",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherDataType >
    CipherData (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"CipherData",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::CipherDataType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::w3::xmlenc::CipherDataType > r (
          dynamic_cast< ::w3::xmlenc::CipherDataType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"CipherData",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (const ::std::wstring& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType > r (
        ::w3::xmlenc::CipherReference (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (const ::std::wstring& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType > r (
        ::w3::xmlenc::CipherReference (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (const ::std::wstring& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType > r (
        ::w3::xmlenc::CipherReference (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::CipherReference (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::CipherReference (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::CipherReference (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::CipherReference (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::CipherReference (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::CipherReference (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType > r (
        ::w3::xmlenc::CipherReference (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType > r (
        ::w3::xmlenc::CipherReference (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType > r (
        ::w3::xmlenc::CipherReference (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType > r (
          ::w3::xmlenc::CipherReference (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"CipherReference",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::CipherReferenceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType > r (
          dynamic_cast< ::w3::xmlenc::CipherReferenceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"CipherReference",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType >
    CipherReference (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"CipherReference",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::CipherReferenceType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::w3::xmlenc::CipherReferenceType > r (
          dynamic_cast< ::w3::xmlenc::CipherReferenceType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"CipherReference",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (const ::std::wstring& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType > r (
        ::w3::xmlenc::EncryptedData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (const ::std::wstring& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType > r (
        ::w3::xmlenc::EncryptedData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (const ::std::wstring& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType > r (
        ::w3::xmlenc::EncryptedData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptedData (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptedData (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptedData (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptedData (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptedData (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptedData (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType > r (
        ::w3::xmlenc::EncryptedData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType > r (
        ::w3::xmlenc::EncryptedData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType > r (
        ::w3::xmlenc::EncryptedData (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType > r (
          ::w3::xmlenc::EncryptedData (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"EncryptedData",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptedDataType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType > r (
          dynamic_cast< ::w3::xmlenc::EncryptedDataType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedData",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType >
    EncryptedData (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"EncryptedData",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptedDataType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::w3::xmlenc::EncryptedDataType > r (
          dynamic_cast< ::w3::xmlenc::EncryptedDataType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedData",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (const ::std::wstring& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType > r (
        ::w3::xmlenc::EncryptedKey (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (const ::std::wstring& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType > r (
        ::w3::xmlenc::EncryptedKey (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (const ::std::wstring& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType > r (
        ::w3::xmlenc::EncryptedKey (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptedKey (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptedKey (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptedKey (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptedKey (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptedKey (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::std::istream& is,
                  const ::std::wstring& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptedKey (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType > r (
        ::w3::xmlenc::EncryptedKey (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType > r (
        ::w3::xmlenc::EncryptedKey (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType > r (
        ::w3::xmlenc::EncryptedKey (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType > r (
          ::w3::xmlenc::EncryptedKey (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"EncryptedKey",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptedKeyType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType > r (
          dynamic_cast< ::w3::xmlenc::EncryptedKeyType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedKey",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType >
    EncryptedKey (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"EncryptedKey",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptedKeyType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::w3::xmlenc::EncryptedKeyType > r (
          dynamic_cast< ::w3::xmlenc::EncryptedKeyType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptedKey",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (const ::std::wstring& u,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType > r (
        ::w3::xmlenc::AgreementMethod (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (const ::std::wstring& u,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType > r (
        ::w3::xmlenc::AgreementMethod (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (const ::std::wstring& u,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType > r (
        ::w3::xmlenc::AgreementMethod (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::std::istream& is,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::AgreementMethod (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::std::istream& is,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::AgreementMethod (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::std::istream& is,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::AgreementMethod (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::AgreementMethod (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::AgreementMethod (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::std::istream& is,
                     const ::std::wstring& sid,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::AgreementMethod (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::xercesc::InputSource& i,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType > r (
        ::w3::xmlenc::AgreementMethod (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::xercesc::InputSource& i,
                     ::xml_schema::error_handler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType > r (
        ::w3::xmlenc::AgreementMethod (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::xercesc::InputSource& i,
                     ::xercesc::DOMErrorHandler& h,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType > r (
        ::w3::xmlenc::AgreementMethod (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (const ::xercesc::DOMDocument& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType > r (
          ::w3::xmlenc::AgreementMethod (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"AgreementMethod",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::AgreementMethodType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType > r (
          dynamic_cast< ::w3::xmlenc::AgreementMethodType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AgreementMethod",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType >
    AgreementMethod (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                     ::xml_schema::flags f,
                     const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"AgreementMethod",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::AgreementMethodType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::w3::xmlenc::AgreementMethodType > r (
          dynamic_cast< ::w3::xmlenc::AgreementMethodType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"AgreementMethod",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (const ::std::wstring& u,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::ReferenceList > r (
        ::w3::xmlenc::ReferenceList_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (const ::std::wstring& u,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::ReferenceList > r (
        ::w3::xmlenc::ReferenceList_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (const ::std::wstring& u,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::ReferenceList > r (
        ::w3::xmlenc::ReferenceList_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::std::istream& is,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::ReferenceList_ (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::std::istream& is,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::ReferenceList_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::std::istream& is,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::ReferenceList_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::ReferenceList_ (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::ReferenceList_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::std::istream& is,
                    const ::std::wstring& sid,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::ReferenceList_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::xercesc::InputSource& i,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::ReferenceList > r (
        ::w3::xmlenc::ReferenceList_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::xercesc::InputSource& i,
                    ::xml_schema::error_handler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::ReferenceList > r (
        ::w3::xmlenc::ReferenceList_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::xercesc::InputSource& i,
                    ::xercesc::DOMErrorHandler& h,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::ReferenceList > r (
        ::w3::xmlenc::ReferenceList_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (const ::xercesc::DOMDocument& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::w3::xmlenc::ReferenceList > r (
          ::w3::xmlenc::ReferenceList_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (n.name () == L"ReferenceList" &&
          n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< ::w3::xmlenc::ReferenceList > r (
          ::xsd::cxx::tree::traits< ::w3::xmlenc::ReferenceList, wchar_t >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ReferenceList",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::ReferenceList >
    ReferenceList_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                    ::xml_schema::flags f,
                    const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == L"ReferenceList" &&
          n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
      {
        ::std::auto_ptr< ::w3::xmlenc::ReferenceList > r (
          ::xsd::cxx::tree::traits< ::w3::xmlenc::ReferenceList, wchar_t >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"ReferenceList",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (const ::std::wstring& u,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType > r (
        ::w3::xmlenc::EncryptionProperties (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (const ::std::wstring& u,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType > r (
        ::w3::xmlenc::EncryptionProperties (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (const ::std::wstring& u,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType > r (
        ::w3::xmlenc::EncryptionProperties (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::std::istream& is,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptionProperties (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::std::istream& is,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptionProperties (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::std::istream& is,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptionProperties (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptionProperties (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptionProperties (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::std::istream& is,
                          const ::std::wstring& sid,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptionProperties (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::xercesc::InputSource& i,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType > r (
        ::w3::xmlenc::EncryptionProperties (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::xercesc::InputSource& i,
                          ::xml_schema::error_handler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType > r (
        ::w3::xmlenc::EncryptionProperties (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::xercesc::InputSource& i,
                          ::xercesc::DOMErrorHandler& h,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType > r (
        ::w3::xmlenc::EncryptionProperties (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (const ::xercesc::DOMDocument& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType > r (
          ::w3::xmlenc::EncryptionProperties (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"EncryptionProperties",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptionPropertiesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType > r (
          dynamic_cast< ::w3::xmlenc::EncryptionPropertiesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptionProperties",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType >
    EncryptionProperties (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                          ::xml_schema::flags f,
                          const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"EncryptionProperties",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptionPropertiesType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertiesType > r (
          dynamic_cast< ::w3::xmlenc::EncryptionPropertiesType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptionProperties",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (const ::std::wstring& u,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType > r (
        ::w3::xmlenc::EncryptionProperty (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (const ::std::wstring& u,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType > r (
        ::w3::xmlenc::EncryptionProperty (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (const ::std::wstring& u,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType > r (
        ::w3::xmlenc::EncryptionProperty (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::std::istream& is,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptionProperty (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::std::istream& is,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptionProperty (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::std::istream& is,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::w3::xmlenc::EncryptionProperty (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptionProperty (isrc, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptionProperty (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::std::istream& is,
                        const ::std::wstring& sid,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::w3::xmlenc::EncryptionProperty (isrc, h, f, p);
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::xercesc::InputSource& i,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType > r (
        ::w3::xmlenc::EncryptionProperty (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::xercesc::InputSource& i,
                        ::xml_schema::error_handler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType > r (
        ::w3::xmlenc::EncryptionProperty (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::xercesc::InputSource& i,
                        ::xercesc::DOMErrorHandler& h,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType > r (
        ::w3::xmlenc::EncryptionProperty (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (const ::xercesc::DOMDocument& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType > r (
          ::w3::xmlenc::EncryptionProperty (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"EncryptionProperty",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptionPropertyType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType > r (
          dynamic_cast< ::w3::xmlenc::EncryptionPropertyType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptionProperty",
        L"http://www.w3.org/2001/04/xmlenc#");
    }

    ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType >
    EncryptionProperty (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                        ::xml_schema::flags f,
                        const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"EncryptionProperty",
          L"http://www.w3.org/2001/04/xmlenc#",
          &::xsd::cxx::tree::factory_impl< ::w3::xmlenc::EncryptionPropertyType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::w3::xmlenc::EncryptionPropertyType > r (
          dynamic_cast< ::w3::xmlenc::EncryptionPropertyType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"EncryptionProperty",
        L"http://www.w3.org/2001/04/xmlenc#");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace w3
{
  namespace xmlenc
  {
    void
    operator<< (::xercesc::DOMElement& e, const EncryptedType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EncryptionMethod
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptionMethod ())
        {
          const EncryptedType::EncryptionMethod_type& x (*i.EncryptionMethod ());
          if (typeid (EncryptedType::EncryptionMethod_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptionMethod",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"EncryptionMethod",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, x);
        }
      }

      // KeyInfo
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.KeyInfo ())
        {
          const EncryptedType::KeyInfo_type& x (*i.KeyInfo ());
          if (typeid (EncryptedType::KeyInfo_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"KeyInfo",
                L"http://www.w3.org/2000/09/xmldsig#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"KeyInfo",
              L"http://www.w3.org/2000/09/xmldsig#",
              true, true, e, x);
        }
      }

      // CipherData
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const EncryptedType::CipherData_type& x (i.CipherData ());
        if (typeid (EncryptedType::CipherData_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"CipherData",
              L"http://www.w3.org/2001/04/xmlenc#",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"CipherData",
            L"http://www.w3.org/2001/04/xmlenc#",
            true, true, e, x);
      }

      // EncryptionProperties
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.EncryptionProperties ())
        {
          const EncryptedType::EncryptionProperties_type& x (*i.EncryptionProperties ());
          if (typeid (EncryptedType::EncryptionProperties_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptionProperties",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"EncryptionProperties",
              L"http://www.w3.org/2001/04/xmlenc#",
              true, true, e, x);
        }
      }

      // Id
      //
      if (i.Id ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }

      // Type
      //
      if (i.Type ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Type",
            e));

        a << *i.Type ();
      }

      // MimeType
      //
      if (i.MimeType ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"MimeType",
            e));

        a << *i.MimeType ();
      }

      // Encoding
      //
      if (i.Encoding ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Encoding",
            e));

        a << *i.Encoding ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EncryptedType >
    _xsd_EncryptedType_type_serializer_init (
      L"EncryptedType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    operator<< (::xercesc::DOMElement& e, const EncryptionMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // KeySize
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.KeySize ())
        {
          const EncryptionMethodType::KeySize_type& x (*i.KeySize ());
          if (typeid (EncryptionMethodType::KeySize_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"KeySize",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"KeySize",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, x);
        }
      }

      // OAEPparams
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.OAEPparams ())
        {
          const EncryptionMethodType::OAEPparams_type& x (*i.OAEPparams ());
          if (typeid (EncryptionMethodType::OAEPparams_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"OAEPparams",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"OAEPparams",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, x);
        }
      }

      // any
      //
      for (EncryptionMethodType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // Algorithm
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Algorithm",
            e));

        a << i.Algorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EncryptionMethodType >
    _xsd_EncryptionMethodType_type_serializer_init (
      L"EncryptionMethodType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    operator<< (::xercesc::DOMElement& e, const KeySizeType& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,const KeySizeType& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const KeySizeType& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, KeySizeType >
    _xsd_KeySizeType_type_serializer_init (
      L"KeySizeType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    CipherData (::std::ostream& o,
                const ::w3::xmlenc::CipherDataType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherData (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    CipherData (::std::ostream& o,
                const ::w3::xmlenc::CipherDataType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherData (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    CipherData (::std::ostream& o,
                const ::w3::xmlenc::CipherDataType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherData (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    CipherData (::xercesc::XMLFormatTarget& t,
                const ::w3::xmlenc::CipherDataType& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherData (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    CipherData (::xercesc::XMLFormatTarget& t,
                const ::w3::xmlenc::CipherDataType& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherData (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    CipherData (::xercesc::XMLFormatTarget& t,
                const ::w3::xmlenc::CipherDataType& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::wstring& e,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherData (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    CipherData (::xercesc::DOMDocument& d,
                const ::w3::xmlenc::CipherDataType& s,
                ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::w3::xmlenc::CipherDataType) == typeid (s))
      {
        if (n.name () == L"CipherData" &&
            n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"CipherData",
            L"http://www.w3.org/2001/04/xmlenc#");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"CipherData",
          L"http://www.w3.org/2001/04/xmlenc#",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    CipherData (const ::w3::xmlenc::CipherDataType& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::w3::xmlenc::CipherDataType) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"CipherData",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"CipherData",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, s, f));
        d = r;
      }

      ::w3::xmlenc::CipherData (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const CipherDataType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // CipherValue
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.CipherValue ())
        {
          const CipherDataType::CipherValue_type& x (*i.CipherValue ());
          if (typeid (CipherDataType::CipherValue_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"CipherValue",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"CipherValue",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, x);
        }
      }

      // CipherReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.CipherReference ())
        {
          const CipherDataType::CipherReference_type& x (*i.CipherReference ());
          if (typeid (CipherDataType::CipherReference_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"CipherReference",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"CipherReference",
              L"http://www.w3.org/2001/04/xmlenc#",
              true, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CipherDataType >
    _xsd_CipherDataType_type_serializer_init (
      L"CipherDataType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    CipherReference (::std::ostream& o,
                     const ::w3::xmlenc::CipherReferenceType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherReference (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    CipherReference (::std::ostream& o,
                     const ::w3::xmlenc::CipherReferenceType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherReference (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    CipherReference (::std::ostream& o,
                     const ::w3::xmlenc::CipherReferenceType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherReference (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    CipherReference (::xercesc::XMLFormatTarget& t,
                     const ::w3::xmlenc::CipherReferenceType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherReference (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    CipherReference (::xercesc::XMLFormatTarget& t,
                     const ::w3::xmlenc::CipherReferenceType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherReference (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    CipherReference (::xercesc::XMLFormatTarget& t,
                     const ::w3::xmlenc::CipherReferenceType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::CipherReference (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    CipherReference (::xercesc::DOMDocument& d,
                     const ::w3::xmlenc::CipherReferenceType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::w3::xmlenc::CipherReferenceType) == typeid (s))
      {
        if (n.name () == L"CipherReference" &&
            n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"CipherReference",
            L"http://www.w3.org/2001/04/xmlenc#");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"CipherReference",
          L"http://www.w3.org/2001/04/xmlenc#",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    CipherReference (const ::w3::xmlenc::CipherReferenceType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::w3::xmlenc::CipherReferenceType) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"CipherReference",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"CipherReference",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, s, f));
        d = r;
      }

      ::w3::xmlenc::CipherReference (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const CipherReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Transforms
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Transforms ())
        {
          const CipherReferenceType::Transforms_type& x (*i.Transforms ());
          if (typeid (CipherReferenceType::Transforms_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Transforms",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Transforms",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, x);
        }
      }

      // URI
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"URI",
            e));

        a << i.URI ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, CipherReferenceType >
    _xsd_CipherReferenceType_type_serializer_init (
      L"CipherReferenceType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    operator<< (::xercesc::DOMElement& e, const TransformsType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Transform
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (TransformsType::Transform_const_iterator
             b (i.Transform ().begin ()), n (i.Transform ().end ());
             b != n; ++b)
        {
          if (typeid (TransformsType::Transform_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Transform",
                L"http://www.w3.org/2000/09/xmldsig#",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Transform",
              L"http://www.w3.org/2000/09/xmldsig#",
              true, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, TransformsType >
    _xsd_TransformsType_type_serializer_init (
      L"TransformsType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    EncryptedData (::std::ostream& o,
                   const ::w3::xmlenc::EncryptedDataType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedData (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedData (::std::ostream& o,
                   const ::w3::xmlenc::EncryptedDataType& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedData (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedData (::std::ostream& o,
                   const ::w3::xmlenc::EncryptedDataType& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedData (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedData (::xercesc::XMLFormatTarget& t,
                   const ::w3::xmlenc::EncryptedDataType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedData (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedData (::xercesc::XMLFormatTarget& t,
                   const ::w3::xmlenc::EncryptedDataType& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedData (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedData (::xercesc::XMLFormatTarget& t,
                   const ::w3::xmlenc::EncryptedDataType& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedData (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedData (::xercesc::DOMDocument& d,
                   const ::w3::xmlenc::EncryptedDataType& s,
                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::w3::xmlenc::EncryptedDataType) == typeid (s))
      {
        if (n.name () == L"EncryptedData" &&
            n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EncryptedData",
            L"http://www.w3.org/2001/04/xmlenc#");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EncryptedData",
          L"http://www.w3.org/2001/04/xmlenc#",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptedData (const ::w3::xmlenc::EncryptedDataType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::w3::xmlenc::EncryptedDataType) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EncryptedData",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"EncryptedData",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, s, f));
        d = r;
      }

      ::w3::xmlenc::EncryptedData (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const EncryptedDataType& i)
    {
      e << static_cast< const ::w3::xmlenc::EncryptedType& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EncryptedDataType >
    _xsd_EncryptedDataType_type_serializer_init (
      L"EncryptedDataType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    EncryptedKey (::std::ostream& o,
                  const ::w3::xmlenc::EncryptedKeyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedKey (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedKey (::std::ostream& o,
                  const ::w3::xmlenc::EncryptedKeyType& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedKey (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedKey (::std::ostream& o,
                  const ::w3::xmlenc::EncryptedKeyType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedKey (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedKey (::xercesc::XMLFormatTarget& t,
                  const ::w3::xmlenc::EncryptedKeyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedKey (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptedKey (::xercesc::XMLFormatTarget& t,
                  const ::w3::xmlenc::EncryptedKeyType& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedKey (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedKey (::xercesc::XMLFormatTarget& t,
                  const ::w3::xmlenc::EncryptedKeyType& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::wstring& e,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptedKey (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptedKey (::xercesc::DOMDocument& d,
                  const ::w3::xmlenc::EncryptedKeyType& s,
                  ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::w3::xmlenc::EncryptedKeyType) == typeid (s))
      {
        if (n.name () == L"EncryptedKey" &&
            n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EncryptedKey",
            L"http://www.w3.org/2001/04/xmlenc#");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EncryptedKey",
          L"http://www.w3.org/2001/04/xmlenc#",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptedKey (const ::w3::xmlenc::EncryptedKeyType& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::w3::xmlenc::EncryptedKeyType) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EncryptedKey",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"EncryptedKey",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, s, f));
        d = r;
      }

      ::w3::xmlenc::EncryptedKey (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const EncryptedKeyType& i)
    {
      e << static_cast< const ::w3::xmlenc::EncryptedType& > (i);

      // ReferenceList
      //
      if (i.ReferenceList ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ReferenceList",
            L"http://www.w3.org/2001/04/xmlenc#",
            e));

        s << *i.ReferenceList ();
      }

      // CarriedKeyName
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.CarriedKeyName ())
        {
          const EncryptedKeyType::CarriedKeyName_type& x (*i.CarriedKeyName ());
          if (typeid (EncryptedKeyType::CarriedKeyName_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"CarriedKeyName",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"CarriedKeyName",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, x);
        }
      }

      // Recipient
      //
      if (i.Recipient ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Recipient",
            e));

        a << *i.Recipient ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EncryptedKeyType >
    _xsd_EncryptedKeyType_type_serializer_init (
      L"EncryptedKeyType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    AgreementMethod (::std::ostream& o,
                     const ::w3::xmlenc::AgreementMethodType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::AgreementMethod (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AgreementMethod (::std::ostream& o,
                     const ::w3::xmlenc::AgreementMethodType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::AgreementMethod (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AgreementMethod (::std::ostream& o,
                     const ::w3::xmlenc::AgreementMethodType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::AgreementMethod (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AgreementMethod (::xercesc::XMLFormatTarget& t,
                     const ::w3::xmlenc::AgreementMethodType& s,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::AgreementMethod (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    AgreementMethod (::xercesc::XMLFormatTarget& t,
                     const ::w3::xmlenc::AgreementMethodType& s,
                     ::xml_schema::error_handler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::AgreementMethod (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AgreementMethod (::xercesc::XMLFormatTarget& t,
                     const ::w3::xmlenc::AgreementMethodType& s,
                     ::xercesc::DOMErrorHandler& h,
                     const ::xml_schema::namespace_infomap& m,
                     const ::std::wstring& e,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::AgreementMethod (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    AgreementMethod (::xercesc::DOMDocument& d,
                     const ::w3::xmlenc::AgreementMethodType& s,
                     ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::w3::xmlenc::AgreementMethodType) == typeid (s))
      {
        if (n.name () == L"AgreementMethod" &&
            n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"AgreementMethod",
            L"http://www.w3.org/2001/04/xmlenc#");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"AgreementMethod",
          L"http://www.w3.org/2001/04/xmlenc#",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    AgreementMethod (const ::w3::xmlenc::AgreementMethodType& s,
                     const ::xml_schema::namespace_infomap& m,
                     ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::w3::xmlenc::AgreementMethodType) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"AgreementMethod",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"AgreementMethod",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, s, f));
        d = r;
      }

      ::w3::xmlenc::AgreementMethod (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const AgreementMethodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // KA-Nonce
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.KA_Nonce ())
        {
          const AgreementMethodType::KA_Nonce_type& x (*i.KA_Nonce ());
          if (typeid (AgreementMethodType::KA_Nonce_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"KA-Nonce",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"KA-Nonce",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, x);
        }
      }

      // any
      //
      for (AgreementMethodType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // OriginatorKeyInfo
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.OriginatorKeyInfo ())
        {
          const AgreementMethodType::OriginatorKeyInfo_type& x (*i.OriginatorKeyInfo ());
          if (typeid (AgreementMethodType::OriginatorKeyInfo_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"OriginatorKeyInfo",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"OriginatorKeyInfo",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, x);
        }
      }

      // RecipientKeyInfo
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.RecipientKeyInfo ())
        {
          const AgreementMethodType::RecipientKeyInfo_type& x (*i.RecipientKeyInfo ());
          if (typeid (AgreementMethodType::RecipientKeyInfo_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"RecipientKeyInfo",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"RecipientKeyInfo",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, x);
        }
      }

      // Algorithm
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Algorithm",
            e));

        a << i.Algorithm ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, AgreementMethodType >
    _xsd_AgreementMethodType_type_serializer_init (
      L"AgreementMethodType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    ReferenceList_ (::std::ostream& o,
                    const ::w3::xmlenc::ReferenceList& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::ReferenceList_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ReferenceList_ (::std::ostream& o,
                    const ::w3::xmlenc::ReferenceList& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::ReferenceList_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ReferenceList_ (::std::ostream& o,
                    const ::w3::xmlenc::ReferenceList& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::ReferenceList_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ReferenceList_ (::xercesc::XMLFormatTarget& t,
                    const ::w3::xmlenc::ReferenceList& s,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::ReferenceList_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    ReferenceList_ (::xercesc::XMLFormatTarget& t,
                    const ::w3::xmlenc::ReferenceList& s,
                    ::xml_schema::error_handler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::ReferenceList_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ReferenceList_ (::xercesc::XMLFormatTarget& t,
                    const ::w3::xmlenc::ReferenceList& s,
                    ::xercesc::DOMErrorHandler& h,
                    const ::xml_schema::namespace_infomap& m,
                    const ::std::wstring& e,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::ReferenceList_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    ReferenceList_ (::xercesc::DOMDocument& d,
                    const ::w3::xmlenc::ReferenceList& s,
                    ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (n.name () == L"ReferenceList" &&
          n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
          n.name (),
          n.namespace_ (),
          L"ReferenceList",
          L"http://www.w3.org/2001/04/xmlenc#");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    ReferenceList_ (const ::w3::xmlenc::ReferenceList& s,
                    const ::xml_schema::namespace_infomap& m,
                    ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< wchar_t > (
          L"ReferenceList",
          L"http://www.w3.org/2001/04/xmlenc#",
          m, f));

      ::w3::xmlenc::ReferenceList_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const ReferenceType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any
      //
      for (ReferenceType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // URI
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"URI",
            e));

        a << i.URI ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, ReferenceType >
    _xsd_ReferenceType_type_serializer_init (
      L"ReferenceType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    EncryptionProperties (::std::ostream& o,
                          const ::w3::xmlenc::EncryptionPropertiesType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperties (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptionProperties (::std::ostream& o,
                          const ::w3::xmlenc::EncryptionPropertiesType& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperties (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionProperties (::std::ostream& o,
                          const ::w3::xmlenc::EncryptionPropertiesType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperties (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionProperties (::xercesc::XMLFormatTarget& t,
                          const ::w3::xmlenc::EncryptionPropertiesType& s,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperties (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptionProperties (::xercesc::XMLFormatTarget& t,
                          const ::w3::xmlenc::EncryptionPropertiesType& s,
                          ::xml_schema::error_handler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperties (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionProperties (::xercesc::XMLFormatTarget& t,
                          const ::w3::xmlenc::EncryptionPropertiesType& s,
                          ::xercesc::DOMErrorHandler& h,
                          const ::xml_schema::namespace_infomap& m,
                          const ::std::wstring& e,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperties (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionProperties (::xercesc::DOMDocument& d,
                          const ::w3::xmlenc::EncryptionPropertiesType& s,
                          ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::w3::xmlenc::EncryptionPropertiesType) == typeid (s))
      {
        if (n.name () == L"EncryptionProperties" &&
            n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EncryptionProperties",
            L"http://www.w3.org/2001/04/xmlenc#");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EncryptionProperties",
          L"http://www.w3.org/2001/04/xmlenc#",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptionProperties (const ::w3::xmlenc::EncryptionPropertiesType& s,
                          const ::xml_schema::namespace_infomap& m,
                          ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::w3::xmlenc::EncryptionPropertiesType) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EncryptionProperties",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"EncryptionProperties",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, s, f));
        d = r;
      }

      ::w3::xmlenc::EncryptionProperties (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const EncryptionPropertiesType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // EncryptionProperty
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (EncryptionPropertiesType::EncryptionProperty_const_iterator
             b (i.EncryptionProperty ().begin ()), n (i.EncryptionProperty ().end ());
             b != n; ++b)
        {
          if (typeid (EncryptionPropertiesType::EncryptionProperty_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"EncryptionProperty",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"EncryptionProperty",
              L"http://www.w3.org/2001/04/xmlenc#",
              true, true, e, *b);
        }
      }

      // Id
      //
      if (i.Id ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EncryptionPropertiesType >
    _xsd_EncryptionPropertiesType_type_serializer_init (
      L"EncryptionPropertiesType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    EncryptionProperty (::std::ostream& o,
                        const ::w3::xmlenc::EncryptionPropertyType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperty (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptionProperty (::std::ostream& o,
                        const ::w3::xmlenc::EncryptionPropertyType& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperty (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionProperty (::std::ostream& o,
                        const ::w3::xmlenc::EncryptionPropertyType& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperty (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionProperty (::xercesc::XMLFormatTarget& t,
                        const ::w3::xmlenc::EncryptionPropertyType& s,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperty (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    EncryptionProperty (::xercesc::XMLFormatTarget& t,
                        const ::w3::xmlenc::EncryptionPropertyType& s,
                        ::xml_schema::error_handler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperty (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionProperty (::xercesc::XMLFormatTarget& t,
                        const ::w3::xmlenc::EncryptionPropertyType& s,
                        ::xercesc::DOMErrorHandler& h,
                        const ::xml_schema::namespace_infomap& m,
                        const ::std::wstring& e,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::w3::xmlenc::EncryptionProperty (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    EncryptionProperty (::xercesc::DOMDocument& d,
                        const ::w3::xmlenc::EncryptionPropertyType& s,
                        ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::w3::xmlenc::EncryptionPropertyType) == typeid (s))
      {
        if (n.name () == L"EncryptionProperty" &&
            n.namespace_ () == L"http://www.w3.org/2001/04/xmlenc#")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"EncryptionProperty",
            L"http://www.w3.org/2001/04/xmlenc#");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"EncryptionProperty",
          L"http://www.w3.org/2001/04/xmlenc#",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    EncryptionProperty (const ::w3::xmlenc::EncryptionPropertyType& s,
                        const ::xml_schema::namespace_infomap& m,
                        ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::w3::xmlenc::EncryptionPropertyType) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"EncryptionProperty",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"EncryptionProperty",
            L"http://www.w3.org/2001/04/xmlenc#",
            m, s, f));
        d = r;
      }

      ::w3::xmlenc::EncryptionProperty (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const EncryptionPropertyType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (EncryptionPropertyType::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // any
      //
      for (EncryptionPropertyType::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }

      // Target
      //
      if (i.Target ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Target",
            e));

        a << *i.Target ();
      }

      // Id
      //
      if (i.Id ())
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"Id",
            e));

        a << *i.Id ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, EncryptionPropertyType >
    _xsd_EncryptionPropertyType_type_serializer_init (
      L"EncryptionPropertyType",
      L"http://www.w3.org/2001/04/xmlenc#");


    void
    operator<< (::xercesc::DOMElement& e, const ReferenceList& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // DataReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ReferenceList::DataReference_const_iterator
             b (i.DataReference ().begin ()), n (i.DataReference ().end ());
             b != n; ++b)
        {
          if (typeid (ReferenceList::DataReference_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"DataReference",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"DataReference",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, *b);
        }
      }

      // KeyReference
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (ReferenceList::KeyReference_const_iterator
             b (i.KeyReference ().begin ()), n (i.KeyReference ().end ());
             b != n; ++b)
        {
          if (typeid (ReferenceList::KeyReference_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"KeyReference",
                L"http://www.w3.org/2001/04/xmlenc#",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"KeyReference",
              L"http://www.w3.org/2001/04/xmlenc#",
              false, true, e, *b);
        }
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

