// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License. You may obtain a copy of 
// the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
// License for the specific language governing permissions and limitations under 
// the License.

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "saml2/bindings/soap-1.1-envelope.hxx"

namespace soap
{
  namespace v11
  {
    // Envelope
    // 

    const Envelope::Header_optional& Envelope::
    Header () const
    {
      return this->Header_;
    }

    Envelope::Header_optional& Envelope::
    Header ()
    {
      return this->Header_;
    }

    void Envelope::
    Header (const Header_type& x)
    {
      this->Header_.set (x);
    }

    void Envelope::
    Header (const Header_optional& x)
    {
      this->Header_ = x;
    }

    void Envelope::
    Header (::std::auto_ptr< Header_type > x)
    {
      this->Header_.set (x);
    }

    const Envelope::Body_type& Envelope::
    Body () const
    {
      return this->Body_.get ();
    }

    Envelope::Body_type& Envelope::
    Body ()
    {
      return this->Body_.get ();
    }

    void Envelope::
    Body (const Body_type& x)
    {
      this->Body_.set (x);
    }

    void Envelope::
    Body (::std::auto_ptr< Body_type > x)
    {
      this->Body_.set (x);
    }

    const Envelope::any_sequence& Envelope::
    any () const
    {
      return this->any_;
    }

    Envelope::any_sequence& Envelope::
    any ()
    {
      return this->any_;
    }

    void Envelope::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const Envelope::any_attribute_set& Envelope::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    Envelope::any_attribute_set& Envelope::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void Envelope::
    any_attribute (const any_attribute_set& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Envelope::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& Envelope::
    dom_document ()
    {
      return *dom_document_;
    }


    // Header
    // 

    const Header::any_sequence& Header::
    any () const
    {
      return this->any_;
    }

    Header::any_sequence& Header::
    any ()
    {
      return this->any_;
    }

    void Header::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const Header::any_attribute_set& Header::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    Header::any_attribute_set& Header::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void Header::
    any_attribute (const any_attribute_set& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Header::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& Header::
    dom_document ()
    {
      return *dom_document_;
    }


    // Body
    // 

    const Body::any_sequence& Body::
    any () const
    {
      return this->any_;
    }

    Body::any_sequence& Body::
    any ()
    {
      return this->any_;
    }

    void Body::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const Body::any_attribute_set& Body::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    Body::any_attribute_set& Body::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void Body::
    any_attribute (const any_attribute_set& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Body::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& Body::
    dom_document ()
    {
      return *dom_document_;
    }


    // encodingStyle
    //

    encodingStyle::
    encodingStyle ()
    {
    }

    encodingStyle::
    encodingStyle (size_type n, const ::xml_schema::uri& x)
    : ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t > (n, x)
    {
    }

    encodingStyle::
    encodingStyle (const encodingStyle& o,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::simple_type (o, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t > (o, f, c)
    {
    }

    // Fault
    // 

    const Fault::faultcode_type& Fault::
    faultcode () const
    {
      return this->faultcode_.get ();
    }

    Fault::faultcode_type& Fault::
    faultcode ()
    {
      return this->faultcode_.get ();
    }

    void Fault::
    faultcode (const faultcode_type& x)
    {
      this->faultcode_.set (x);
    }

    void Fault::
    faultcode (::std::auto_ptr< faultcode_type > x)
    {
      this->faultcode_.set (x);
    }

    const Fault::faultstring_type& Fault::
    faultstring () const
    {
      return this->faultstring_.get ();
    }

    Fault::faultstring_type& Fault::
    faultstring ()
    {
      return this->faultstring_.get ();
    }

    void Fault::
    faultstring (const faultstring_type& x)
    {
      this->faultstring_.set (x);
    }

    void Fault::
    faultstring (::std::auto_ptr< faultstring_type > x)
    {
      this->faultstring_.set (x);
    }

    const Fault::faultactor_optional& Fault::
    faultactor () const
    {
      return this->faultactor_;
    }

    Fault::faultactor_optional& Fault::
    faultactor ()
    {
      return this->faultactor_;
    }

    void Fault::
    faultactor (const faultactor_type& x)
    {
      this->faultactor_.set (x);
    }

    void Fault::
    faultactor (const faultactor_optional& x)
    {
      this->faultactor_ = x;
    }

    void Fault::
    faultactor (::std::auto_ptr< faultactor_type > x)
    {
      this->faultactor_.set (x);
    }

    const Fault::detail_optional& Fault::
    detail () const
    {
      return this->detail_;
    }

    Fault::detail_optional& Fault::
    detail ()
    {
      return this->detail_;
    }

    void Fault::
    detail (const detail_type& x)
    {
      this->detail_.set (x);
    }

    void Fault::
    detail (const detail_optional& x)
    {
      this->detail_ = x;
    }

    void Fault::
    detail (::std::auto_ptr< detail_type > x)
    {
      this->detail_.set (x);
    }


    // detail
    // 

    const detail::any_sequence& detail::
    any () const
    {
      return this->any_;
    }

    detail::any_sequence& detail::
    any ()
    {
      return this->any_;
    }

    void detail::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const detail::any_attribute_set& detail::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    detail::any_attribute_set& detail::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void detail::
    any_attribute (const any_attribute_set& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& detail::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& detail::
    dom_document ()
    {
      return *dom_document_;
    }


    // mustUnderstand
    // 
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace soap
{
  namespace v11
  {
    // Envelope
    //

    Envelope::
    Envelope ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (::xml_schema::flags (), this),
      Body_ (::xml_schema::flags (), this),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
    }

    Envelope::
    Envelope (const Body_type& Body)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (::xml_schema::flags (), this),
      Body_ (Body, ::xml_schema::flags (), this),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
    }

    Envelope::
    Envelope (::std::auto_ptr< Body_type >& Body)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (::xml_schema::flags (), this),
      Body_ (Body, ::xml_schema::flags (), this),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
    }

    Envelope::
    Envelope (const Envelope& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (x.Header_, f, this),
      Body_ (x.Body_, f, this),
      any_ (x.any_, this->dom_document ()),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    Envelope::
    Envelope (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (f, this),
      Body_ (f, this),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void Envelope::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Header
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Header",
              L"http://schemas.xmlsoap.org/soap/envelope/",
              &::xsd::cxx::tree::factory_impl< Header_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Header_)
            {
              ::std::auto_ptr< Header_type > r (
                dynamic_cast< Header_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Header_.set (r);
              continue;
            }
          }
        }

        // Body
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Body",
              L"http://schemas.xmlsoap.org/soap/envelope/",
              &::xsd::cxx::tree::factory_impl< Body_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Body_.present ())
            {
              ::std::auto_ptr< Body_type > r (
                dynamic_cast< Body_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Body_.set (r);
              continue;
            }
          }
        }

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"http://schemas.xmlsoap.org/soap/envelope/"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      if (!Body_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Body",
          L"http://schemas.xmlsoap.org/soap/envelope/");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"http://schemas.xmlsoap.org/soap/envelope/" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Envelope* Envelope::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Envelope (*this, f, c);
    }

    Envelope::
    ~Envelope ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Envelope >
    _xsd_Envelope_type_factory_init (
      L"Envelope",
      L"http://schemas.xmlsoap.org/soap/envelope/");

    // Header
    //

    Header::
    Header ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
    }

    Header::
    Header (const Header& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    Header::
    Header (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void Header::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if ((!n.namespace_ ().empty () && n.namespace_ () != L"http://schemas.xmlsoap.org/soap/envelope/"))
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"http://schemas.xmlsoap.org/soap/envelope/" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Header* Header::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Header (*this, f, c);
    }

    Header::
    ~Header ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Header >
    _xsd_Header_type_factory_init (
      L"Header",
      L"http://schemas.xmlsoap.org/soap/envelope/");

    // Body
    //

    Body::
    Body ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
    }

    Body::
    Body (const Body& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    Body::
    Body (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void Body::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if (true)
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Body* Body::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Body (*this, f, c);
    }

    Body::
    ~Body ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Body >
    _xsd_Body_type_factory_init (
      L"Body",
      L"http://schemas.xmlsoap.org/soap/envelope/");

    // encodingStyle
    //

    encodingStyle::
    encodingStyle (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::simple_type (e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t > (e, f, c)
    {
    }

    encodingStyle::
    encodingStyle (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::simple_type (a, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t > (a, f, c)
    {
    }

    encodingStyle::
    encodingStyle (const ::std::wstring& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::simple_type (s, e, f, c),
      ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t > (s, e, f, c)
    {
    }

    encodingStyle* encodingStyle::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class encodingStyle (*this, f, c);
    }

    encodingStyle::
    ~encodingStyle ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, encodingStyle >
    _xsd_encodingStyle_type_factory_init (
      L"encodingStyle",
      L"http://schemas.xmlsoap.org/soap/envelope/");

    // Fault
    //

    Fault::
    Fault ()
    : ::xml_schema::type (),
      faultcode_ (::xml_schema::flags (), this),
      faultstring_ (::xml_schema::flags (), this),
      faultactor_ (::xml_schema::flags (), this),
      detail_ (::xml_schema::flags (), this)
    {
    }

    Fault::
    Fault (const faultcode_type& faultcode,
           const faultstring_type& faultstring)
    : ::xml_schema::type (),
      faultcode_ (faultcode, ::xml_schema::flags (), this),
      faultstring_ (faultstring, ::xml_schema::flags (), this),
      faultactor_ (::xml_schema::flags (), this),
      detail_ (::xml_schema::flags (), this)
    {
    }

    Fault::
    Fault (::std::auto_ptr< faultcode_type >& faultcode,
           ::std::auto_ptr< faultstring_type >& faultstring)
    : ::xml_schema::type (),
      faultcode_ (faultcode, ::xml_schema::flags (), this),
      faultstring_ (faultstring, ::xml_schema::flags (), this),
      faultactor_ (::xml_schema::flags (), this),
      detail_ (::xml_schema::flags (), this)
    {
    }

    Fault::
    Fault (const Fault& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      faultcode_ (x.faultcode_, f, this),
      faultstring_ (x.faultstring_, f, this),
      faultactor_ (x.faultactor_, f, this),
      detail_ (x.detail_, f, this)
    {
    }

    Fault::
    Fault (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      faultcode_ (f, this),
      faultstring_ (f, this),
      faultactor_ (f, this),
      detail_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void Fault::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // faultcode
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"faultcode",
              L"",
              &::xsd::cxx::tree::factory_impl< faultcode_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!faultcode_.present ())
            {
              ::std::auto_ptr< faultcode_type > r (
                dynamic_cast< faultcode_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->faultcode_.set (r);
              continue;
            }
          }
        }

        // faultstring
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"faultstring",
              L"",
              &::xsd::cxx::tree::factory_impl< faultstring_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!faultstring_.present ())
            {
              ::std::auto_ptr< faultstring_type > r (
                dynamic_cast< faultstring_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->faultstring_.set (r);
              continue;
            }
          }
        }

        // faultactor
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"faultactor",
              L"",
              &::xsd::cxx::tree::factory_impl< faultactor_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->faultactor_)
            {
              ::std::auto_ptr< faultactor_type > r (
                dynamic_cast< faultactor_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->faultactor_.set (r);
              continue;
            }
          }
        }

        // detail
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"detail",
              L"",
              &::xsd::cxx::tree::factory_impl< detail_type >,
              false, false, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->detail_)
            {
              ::std::auto_ptr< detail_type > r (
                dynamic_cast< detail_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->detail_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!faultcode_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"faultcode",
          L"");
      }

      if (!faultstring_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"faultstring",
          L"");
      }
    }

    Fault* Fault::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Fault (*this, f, c);
    }

    Fault::
    ~Fault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Fault >
    _xsd_Fault_type_factory_init (
      L"Fault",
      L"http://schemas.xmlsoap.org/soap/envelope/");

    // detail
    //

    detail::
    detail ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
    }

    detail::
    detail (const detail& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    detail::
    detail (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void detail::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if (true)
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any_attribute
        //
        if ((n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    detail* detail::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class detail (*this, f, c);
    }

    detail::
    ~detail ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, detail >
    _xsd_detail_type_factory_init (
      L"detail",
      L"http://schemas.xmlsoap.org/soap/envelope/");

    // mustUnderstand
    //

    mustUnderstand::
    mustUnderstand ()
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, wchar_t, ::xml_schema::simple_type > ()
    {
    }

    mustUnderstand::
    mustUnderstand (const ::xml_schema::boolean& _xsd_boolean_base)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, wchar_t, ::xml_schema::simple_type > (_xsd_boolean_base)
    {
    }

    mustUnderstand::
    mustUnderstand (const mustUnderstand& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, wchar_t, ::xml_schema::simple_type > (x, f, c)
    {
    }

    mustUnderstand::
    mustUnderstand (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, wchar_t, ::xml_schema::simple_type > (e, f, c)
    {
    }

    mustUnderstand::
    mustUnderstand (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, wchar_t, ::xml_schema::simple_type > (a, f, c)
    {
    }

    mustUnderstand::
    mustUnderstand (const ::std::wstring& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
    : ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, wchar_t, ::xml_schema::simple_type > (s, e, f, c)
    {
    }

    mustUnderstand* mustUnderstand::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class mustUnderstand (*this, f, c);
    }

    mustUnderstand::
    ~mustUnderstand ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace soap
{
  namespace v11
  {
    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (const ::std::wstring& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v11::Envelope > r (
        ::soap::v11::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (const ::std::wstring& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Envelope > r (
        ::soap::v11::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (const ::std::wstring& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Envelope > r (
        ::soap::v11::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Envelope_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Envelope_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Envelope_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Envelope_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Envelope_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::std::istream& is,
               const ::std::wstring& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Envelope_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v11::Envelope > r (
        ::soap::v11::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Envelope > r (
        ::soap::v11::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Envelope > r (
        ::soap::v11::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v11::Envelope > r (
          ::soap::v11::Envelope_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Envelope",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          &::xsd::cxx::tree::factory_impl< ::soap::v11::Envelope >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v11::Envelope > r (
          dynamic_cast< ::soap::v11::Envelope* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Envelope",
        L"http://schemas.xmlsoap.org/soap/envelope/");
    }

    ::std::auto_ptr< ::soap::v11::Envelope >
    Envelope_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Envelope",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          &::xsd::cxx::tree::factory_impl< ::soap::v11::Envelope >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v11::Envelope > r (
          dynamic_cast< ::soap::v11::Envelope* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Envelope",
        L"http://schemas.xmlsoap.org/soap/envelope/");
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v11::Header > r (
        ::soap::v11::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Header > r (
        ::soap::v11::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Header > r (
        ::soap::v11::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Header_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Header_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Header_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Header_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Header_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Header_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v11::Header > r (
        ::soap::v11::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Header > r (
        ::soap::v11::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Header > r (
        ::soap::v11::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v11::Header > r (
          ::soap::v11::Header_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Header",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          &::xsd::cxx::tree::factory_impl< ::soap::v11::Header >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v11::Header > r (
          dynamic_cast< ::soap::v11::Header* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Header",
        L"http://schemas.xmlsoap.org/soap/envelope/");
    }

    ::std::auto_ptr< ::soap::v11::Header >
    Header_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Header",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          &::xsd::cxx::tree::factory_impl< ::soap::v11::Header >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v11::Header > r (
          dynamic_cast< ::soap::v11::Header* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Header",
        L"http://schemas.xmlsoap.org/soap/envelope/");
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (const ::std::wstring& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v11::Body > r (
        ::soap::v11::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (const ::std::wstring& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Body > r (
        ::soap::v11::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (const ::std::wstring& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Body > r (
        ::soap::v11::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Body_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Body_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Body_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::std::istream& is,
           const ::std::wstring& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Body_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::std::istream& is,
           const ::std::wstring& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Body_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::std::istream& is,
           const ::std::wstring& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Body_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v11::Body > r (
        ::soap::v11::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Body > r (
        ::soap::v11::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Body > r (
        ::soap::v11::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v11::Body > r (
          ::soap::v11::Body_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Body",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          &::xsd::cxx::tree::factory_impl< ::soap::v11::Body >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v11::Body > r (
          dynamic_cast< ::soap::v11::Body* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Body",
        L"http://schemas.xmlsoap.org/soap/envelope/");
    }

    ::std::auto_ptr< ::soap::v11::Body >
    Body_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Body",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          &::xsd::cxx::tree::factory_impl< ::soap::v11::Body >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v11::Body > r (
          dynamic_cast< ::soap::v11::Body* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Body",
        L"http://schemas.xmlsoap.org/soap/envelope/");
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (const ::std::wstring& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v11::Fault > r (
        ::soap::v11::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (const ::std::wstring& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Fault > r (
        ::soap::v11::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (const ::std::wstring& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Fault > r (
        ::soap::v11::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Fault_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Fault_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v11::Fault_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Fault_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Fault_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::std::istream& is,
            const ::std::wstring& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v11::Fault_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v11::Fault > r (
        ::soap::v11::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Fault > r (
        ::soap::v11::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v11::Fault > r (
        ::soap::v11::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v11::Fault > r (
          ::soap::v11::Fault_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Fault",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          &::xsd::cxx::tree::factory_impl< ::soap::v11::Fault >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v11::Fault > r (
          dynamic_cast< ::soap::v11::Fault* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Fault",
        L"http://schemas.xmlsoap.org/soap/envelope/");
    }

    ::std::auto_ptr< ::soap::v11::Fault >
    Fault_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Fault",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          &::xsd::cxx::tree::factory_impl< ::soap::v11::Fault >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v11::Fault > r (
          dynamic_cast< ::soap::v11::Fault* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Fault",
        L"http://schemas.xmlsoap.org/soap/envelope/");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace soap
{
  namespace v11
  {
    void
    Envelope_ (::std::ostream& o,
               const ::soap::v11::Envelope& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Envelope_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Envelope_ (::std::ostream& o,
               const ::soap::v11::Envelope& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Envelope_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Envelope_ (::std::ostream& o,
               const ::soap::v11::Envelope& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Envelope_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Envelope_ (::xercesc::XMLFormatTarget& t,
               const ::soap::v11::Envelope& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Envelope_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Envelope_ (::xercesc::XMLFormatTarget& t,
               const ::soap::v11::Envelope& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Envelope_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Envelope_ (::xercesc::XMLFormatTarget& t,
               const ::soap::v11::Envelope& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Envelope_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Envelope_ (::xercesc::DOMDocument& d,
               const ::soap::v11::Envelope& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v11::Envelope) == typeid (s))
      {
        if (n.name () == L"Envelope" &&
            n.namespace_ () == L"http://schemas.xmlsoap.org/soap/envelope/")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Envelope",
            L"http://schemas.xmlsoap.org/soap/envelope/");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Envelope",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Envelope_ (const ::soap::v11::Envelope& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v11::Envelope) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Envelope",
            L"http://schemas.xmlsoap.org/soap/envelope/",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"Envelope",
            L"http://schemas.xmlsoap.org/soap/envelope/",
            m, s, f));
        d = r;
      }

      ::soap::v11::Envelope_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Envelope& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (Envelope::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // Header
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Header ())
        {
          const Envelope::Header_type& x (*i.Header ());
          if (typeid (Envelope::Header_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Header",
                L"http://schemas.xmlsoap.org/soap/envelope/",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Header",
              L"http://schemas.xmlsoap.org/soap/envelope/",
              true, true, e, x);
        }
      }

      // Body
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Envelope::Body_type& x (i.Body ());
        if (typeid (Envelope::Body_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Body",
              L"http://schemas.xmlsoap.org/soap/envelope/",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Body",
            L"http://schemas.xmlsoap.org/soap/envelope/",
            true, true, e, x);
      }

      // any
      //
      for (Envelope::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Envelope >
    _xsd_Envelope_type_serializer_init (
      L"Envelope",
      L"http://schemas.xmlsoap.org/soap/envelope/");


    void
    Header_ (::std::ostream& o,
             const ::soap::v11::Header& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Header_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Header_ (::std::ostream& o,
             const ::soap::v11::Header& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Header_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Header_ (::std::ostream& o,
             const ::soap::v11::Header& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Header_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Header_ (::xercesc::XMLFormatTarget& t,
             const ::soap::v11::Header& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Header_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Header_ (::xercesc::XMLFormatTarget& t,
             const ::soap::v11::Header& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Header_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Header_ (::xercesc::XMLFormatTarget& t,
             const ::soap::v11::Header& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Header_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Header_ (::xercesc::DOMDocument& d,
             const ::soap::v11::Header& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v11::Header) == typeid (s))
      {
        if (n.name () == L"Header" &&
            n.namespace_ () == L"http://schemas.xmlsoap.org/soap/envelope/")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Header",
            L"http://schemas.xmlsoap.org/soap/envelope/");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Header",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Header_ (const ::soap::v11::Header& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v11::Header) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Header",
            L"http://schemas.xmlsoap.org/soap/envelope/",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"Header",
            L"http://schemas.xmlsoap.org/soap/envelope/",
            m, s, f));
        d = r;
      }

      ::soap::v11::Header_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Header& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (Header::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // any
      //
      for (Header::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Header >
    _xsd_Header_type_serializer_init (
      L"Header",
      L"http://schemas.xmlsoap.org/soap/envelope/");


    void
    Body_ (::std::ostream& o,
           const ::soap::v11::Body& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Body_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Body_ (::std::ostream& o,
           const ::soap::v11::Body& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Body_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Body_ (::std::ostream& o,
           const ::soap::v11::Body& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Body_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Body_ (::xercesc::XMLFormatTarget& t,
           const ::soap::v11::Body& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Body_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Body_ (::xercesc::XMLFormatTarget& t,
           const ::soap::v11::Body& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Body_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Body_ (::xercesc::XMLFormatTarget& t,
           const ::soap::v11::Body& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Body_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Body_ (::xercesc::DOMDocument& d,
           const ::soap::v11::Body& s,
           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v11::Body) == typeid (s))
      {
        if (n.name () == L"Body" &&
            n.namespace_ () == L"http://schemas.xmlsoap.org/soap/envelope/")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Body",
            L"http://schemas.xmlsoap.org/soap/envelope/");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Body",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Body_ (const ::soap::v11::Body& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v11::Body) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Body",
            L"http://schemas.xmlsoap.org/soap/envelope/",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"Body",
            L"http://schemas.xmlsoap.org/soap/envelope/",
            m, s, f));
        d = r;
      }

      ::soap::v11::Body_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Body& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (Body::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // any
      //
      for (Body::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Body >
    _xsd_Body_type_serializer_init (
      L"Body",
      L"http://schemas.xmlsoap.org/soap/envelope/");


    void
    operator<< (::xercesc::DOMElement& e, const encodingStyle& i)
    {
      e << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const encodingStyle& i)
    {
      a << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const encodingStyle& i)
    {
      l << static_cast< const ::xsd::cxx::tree::list< ::xml_schema::uri, wchar_t >& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, encodingStyle >
    _xsd_encodingStyle_type_serializer_init (
      L"encodingStyle",
      L"http://schemas.xmlsoap.org/soap/envelope/");


    void
    Fault_ (::std::ostream& o,
            const ::soap::v11::Fault& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Fault_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Fault_ (::std::ostream& o,
            const ::soap::v11::Fault& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Fault_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Fault_ (::std::ostream& o,
            const ::soap::v11::Fault& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Fault_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Fault_ (::xercesc::XMLFormatTarget& t,
            const ::soap::v11::Fault& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Fault_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Fault_ (::xercesc::XMLFormatTarget& t,
            const ::soap::v11::Fault& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Fault_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Fault_ (::xercesc::XMLFormatTarget& t,
            const ::soap::v11::Fault& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v11::Fault_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Fault_ (::xercesc::DOMDocument& d,
            const ::soap::v11::Fault& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v11::Fault) == typeid (s))
      {
        if (n.name () == L"Fault" &&
            n.namespace_ () == L"http://schemas.xmlsoap.org/soap/envelope/")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Fault",
            L"http://schemas.xmlsoap.org/soap/envelope/");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Fault",
          L"http://schemas.xmlsoap.org/soap/envelope/",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Fault_ (const ::soap::v11::Fault& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v11::Fault) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Fault",
            L"http://schemas.xmlsoap.org/soap/envelope/",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"Fault",
            L"http://schemas.xmlsoap.org/soap/envelope/",
            m, s, f));
        d = r;
      }

      ::soap::v11::Fault_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Fault& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // faultcode
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Fault::faultcode_type& x (i.faultcode ());
        if (typeid (Fault::faultcode_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"faultcode",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"faultcode",
            L"",
            false, false, e, x);
      }

      // faultstring
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Fault::faultstring_type& x (i.faultstring ());
        if (typeid (Fault::faultstring_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"faultstring",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"faultstring",
            L"",
            false, false, e, x);
      }

      // faultactor
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.faultactor ())
        {
          const Fault::faultactor_type& x (*i.faultactor ());
          if (typeid (Fault::faultactor_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"faultactor",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"faultactor",
              L"",
              false, false, e, x);
        }
      }

      // detail
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.detail ())
        {
          const Fault::detail_type& x (*i.detail ());
          if (typeid (Fault::detail_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"detail",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"detail",
              L"",
              false, false, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Fault >
    _xsd_Fault_type_serializer_init (
      L"Fault",
      L"http://schemas.xmlsoap.org/soap/envelope/");


    void
    operator<< (::xercesc::DOMElement& e, const detail& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (detail::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // any
      //
      for (detail::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, detail >
    _xsd_detail_type_serializer_init (
      L"detail",
      L"http://schemas.xmlsoap.org/soap/envelope/");


    void
    operator<< (::xercesc::DOMElement& e, const mustUnderstand& i)
    {
      e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a,const mustUnderstand& i)
    {
      a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, wchar_t, ::xml_schema::simple_type >& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const mustUnderstand& i)
    {
      l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, wchar_t, ::xml_schema::simple_type >& > (i);
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

