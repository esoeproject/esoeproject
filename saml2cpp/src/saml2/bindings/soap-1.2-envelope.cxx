// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License. You may obtain a copy of 
// the License at 
// 
//   http://www.apache.org/licenses/LICENSE-2.0 
// 
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
// License for the specific language governing permissions and limitations under 
// the License.

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "saml2/bindings/soap-1.2-envelope.hxx"

namespace soap
{
  namespace v12
  {
    // Envelope
    // 

    const Envelope::Header_optional& Envelope::
    Header () const
    {
      return this->Header_;
    }

    Envelope::Header_optional& Envelope::
    Header ()
    {
      return this->Header_;
    }

    void Envelope::
    Header (const Header_type& x)
    {
      this->Header_.set (x);
    }

    void Envelope::
    Header (const Header_optional& x)
    {
      this->Header_ = x;
    }

    void Envelope::
    Header (::std::auto_ptr< Header_type > x)
    {
      this->Header_.set (x);
    }

    const Envelope::Body_type& Envelope::
    Body () const
    {
      return this->Body_.get ();
    }

    Envelope::Body_type& Envelope::
    Body ()
    {
      return this->Body_.get ();
    }

    void Envelope::
    Body (const Body_type& x)
    {
      this->Body_.set (x);
    }

    void Envelope::
    Body (::std::auto_ptr< Body_type > x)
    {
      this->Body_.set (x);
    }

    const Envelope::any_attribute_set& Envelope::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    Envelope::any_attribute_set& Envelope::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void Envelope::
    any_attribute (const any_attribute_set& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Envelope::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& Envelope::
    dom_document ()
    {
      return *dom_document_;
    }


    // Header
    // 

    const Header::any_sequence& Header::
    any () const
    {
      return this->any_;
    }

    Header::any_sequence& Header::
    any ()
    {
      return this->any_;
    }

    void Header::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const Header::any_attribute_set& Header::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    Header::any_attribute_set& Header::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void Header::
    any_attribute (const any_attribute_set& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Header::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& Header::
    dom_document ()
    {
      return *dom_document_;
    }


    // Body
    // 

    const Body::any_sequence& Body::
    any () const
    {
      return this->any_;
    }

    Body::any_sequence& Body::
    any ()
    {
      return this->any_;
    }

    void Body::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const Body::any_attribute_set& Body::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    Body::any_attribute_set& Body::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void Body::
    any_attribute (const any_attribute_set& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& Body::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& Body::
    dom_document ()
    {
      return *dom_document_;
    }


    // Fault
    // 

    const Fault::Code_type& Fault::
    Code () const
    {
      return this->Code_.get ();
    }

    Fault::Code_type& Fault::
    Code ()
    {
      return this->Code_.get ();
    }

    void Fault::
    Code (const Code_type& x)
    {
      this->Code_.set (x);
    }

    void Fault::
    Code (::std::auto_ptr< Code_type > x)
    {
      this->Code_.set (x);
    }

    const Fault::Reason_type& Fault::
    Reason () const
    {
      return this->Reason_.get ();
    }

    Fault::Reason_type& Fault::
    Reason ()
    {
      return this->Reason_.get ();
    }

    void Fault::
    Reason (const Reason_type& x)
    {
      this->Reason_.set (x);
    }

    void Fault::
    Reason (::std::auto_ptr< Reason_type > x)
    {
      this->Reason_.set (x);
    }

    const Fault::Node_optional& Fault::
    Node () const
    {
      return this->Node_;
    }

    Fault::Node_optional& Fault::
    Node ()
    {
      return this->Node_;
    }

    void Fault::
    Node (const Node_type& x)
    {
      this->Node_.set (x);
    }

    void Fault::
    Node (const Node_optional& x)
    {
      this->Node_ = x;
    }

    void Fault::
    Node (::std::auto_ptr< Node_type > x)
    {
      this->Node_.set (x);
    }

    const Fault::Role_optional& Fault::
    Role () const
    {
      return this->Role_;
    }

    Fault::Role_optional& Fault::
    Role ()
    {
      return this->Role_;
    }

    void Fault::
    Role (const Role_type& x)
    {
      this->Role_.set (x);
    }

    void Fault::
    Role (const Role_optional& x)
    {
      this->Role_ = x;
    }

    void Fault::
    Role (::std::auto_ptr< Role_type > x)
    {
      this->Role_.set (x);
    }

    const Fault::Detail_optional& Fault::
    Detail () const
    {
      return this->Detail_;
    }

    Fault::Detail_optional& Fault::
    Detail ()
    {
      return this->Detail_;
    }

    void Fault::
    Detail (const Detail_type& x)
    {
      this->Detail_.set (x);
    }

    void Fault::
    Detail (const Detail_optional& x)
    {
      this->Detail_ = x;
    }

    void Fault::
    Detail (::std::auto_ptr< Detail_type > x)
    {
      this->Detail_.set (x);
    }


    // faultreason
    // 

    const faultreason::Text_sequence& faultreason::
    Text () const
    {
      return this->Text_;
    }

    faultreason::Text_sequence& faultreason::
    Text ()
    {
      return this->Text_;
    }

    void faultreason::
    Text (const Text_sequence& s)
    {
      this->Text_ = s;
    }


    // reasontext
    // 

    const reasontext::lang_type& reasontext::
    lang () const
    {
      return this->lang_.get ();
    }

    reasontext::lang_type& reasontext::
    lang ()
    {
      return this->lang_.get ();
    }

    void reasontext::
    lang (const lang_type& x)
    {
      this->lang_.set (x);
    }

    void reasontext::
    lang (::std::auto_ptr< lang_type > x)
    {
      this->lang_.set (x);
    }


    // faultcode
    // 

    const faultcode::Value_type& faultcode::
    Value () const
    {
      return this->Value_.get ();
    }

    faultcode::Value_type& faultcode::
    Value ()
    {
      return this->Value_.get ();
    }

    void faultcode::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }

    void faultcode::
    Value (::std::auto_ptr< Value_type > x)
    {
      this->Value_.set (x);
    }

    const faultcode::Subcode_optional& faultcode::
    Subcode () const
    {
      return this->Subcode_;
    }

    faultcode::Subcode_optional& faultcode::
    Subcode ()
    {
      return this->Subcode_;
    }

    void faultcode::
    Subcode (const Subcode_type& x)
    {
      this->Subcode_.set (x);
    }

    void faultcode::
    Subcode (const Subcode_optional& x)
    {
      this->Subcode_ = x;
    }

    void faultcode::
    Subcode (::std::auto_ptr< Subcode_type > x)
    {
      this->Subcode_.set (x);
    }


    // faultcodeEnum
    // 

    faultcodeEnum::
    faultcodeEnum ()
    : ::xml_schema::qname ()
    {
    }

    faultcodeEnum::
    faultcodeEnum (const ::xml_schema::qname& v)
    : ::xml_schema::qname (v)
    {
    }

    faultcodeEnum::
    faultcodeEnum (const faultcodeEnum& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::qname (v, f, c)
    {
    }


    // subcode
    // 

    const subcode::Value_type& subcode::
    Value () const
    {
      return this->Value_.get ();
    }

    subcode::Value_type& subcode::
    Value ()
    {
      return this->Value_.get ();
    }

    void subcode::
    Value (const Value_type& x)
    {
      this->Value_.set (x);
    }

    void subcode::
    Value (::std::auto_ptr< Value_type > x)
    {
      this->Value_.set (x);
    }

    const subcode::Subcode_optional& subcode::
    Subcode () const
    {
      return this->Subcode_;
    }

    subcode::Subcode_optional& subcode::
    Subcode ()
    {
      return this->Subcode_;
    }

    void subcode::
    Subcode (const Subcode_type& x)
    {
      this->Subcode_.set (x);
    }

    void subcode::
    Subcode (const Subcode_optional& x)
    {
      this->Subcode_ = x;
    }

    void subcode::
    Subcode (::std::auto_ptr< Subcode_type > x)
    {
      this->Subcode_.set (x);
    }


    // detail
    // 

    const detail::any_sequence& detail::
    any () const
    {
      return this->any_;
    }

    detail::any_sequence& detail::
    any ()
    {
      return this->any_;
    }

    void detail::
    any (const any_sequence& s)
    {
      this->any_ = s;
    }

    const detail::any_attribute_set& detail::
    any_attribute () const
    {
      return this->any_attribute_;
    }

    detail::any_attribute_set& detail::
    any_attribute ()
    {
      return this->any_attribute_;
    }

    void detail::
    any_attribute (const any_attribute_set& s)
    {
      this->any_attribute_ = s;
    }

    const ::xercesc::DOMDocument& detail::
    dom_document () const
    {
      return *dom_document_;
    }

    ::xercesc::DOMDocument& detail::
    dom_document ()
    {
      return *dom_document_;
    }


    // NotUnderstoodType
    // 

    const NotUnderstoodType::qname_type& NotUnderstoodType::
    qname () const
    {
      return this->qname_.get ();
    }

    NotUnderstoodType::qname_type& NotUnderstoodType::
    qname ()
    {
      return this->qname_.get ();
    }

    void NotUnderstoodType::
    qname (const qname_type& x)
    {
      this->qname_.set (x);
    }

    void NotUnderstoodType::
    qname (::std::auto_ptr< qname_type > x)
    {
      this->qname_.set (x);
    }


    // SupportedEnvType
    // 

    const SupportedEnvType::qname_type& SupportedEnvType::
    qname () const
    {
      return this->qname_.get ();
    }

    SupportedEnvType::qname_type& SupportedEnvType::
    qname ()
    {
      return this->qname_.get ();
    }

    void SupportedEnvType::
    qname (const qname_type& x)
    {
      this->qname_.set (x);
    }

    void SupportedEnvType::
    qname (::std::auto_ptr< qname_type > x)
    {
      this->qname_.set (x);
    }


    // UpgradeType
    // 

    const UpgradeType::SupportedEnvelope_sequence& UpgradeType::
    SupportedEnvelope () const
    {
      return this->SupportedEnvelope_;
    }

    UpgradeType::SupportedEnvelope_sequence& UpgradeType::
    SupportedEnvelope ()
    {
      return this->SupportedEnvelope_;
    }

    void UpgradeType::
    SupportedEnvelope (const SupportedEnvelope_sequence& s)
    {
      this->SupportedEnvelope_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, wchar_t >
  type_factory_plate_init;
}

namespace soap
{
  namespace v12
  {
    // Envelope
    //

    Envelope::
    Envelope ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (::xml_schema::flags (), this),
      Body_ (::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    Envelope::
    Envelope (const Body_type& Body)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (::xml_schema::flags (), this),
      Body_ (Body, ::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    Envelope::
    Envelope (::std::auto_ptr< Body_type >& Body)
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (::xml_schema::flags (), this),
      Body_ (Body, ::xml_schema::flags (), this),
      any_attribute_ (this->dom_document ())
    {
    }

    Envelope::
    Envelope (const Envelope& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (x.Header_, f, this),
      Body_ (x.Body_, f, this),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    Envelope::
    Envelope (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      Header_ (f, this),
      Body_ (f, this),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void Envelope::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Header
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Header",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Header_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Header_)
            {
              ::std::auto_ptr< Header_type > r (
                dynamic_cast< Header_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Header_.set (r);
              continue;
            }
          }
        }

        // Body
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Body",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Body_type >,
              true, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Body_.present ())
            {
              ::std::auto_ptr< Body_type > r (
                dynamic_cast< Body_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Body_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!Body_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Body",
          L"http://www.w3.org/2003/05/soap-envelope");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"http://www.w3.org/2003/05/soap-envelope" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Envelope* Envelope::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Envelope (*this, f, c);
    }

    Envelope::
    ~Envelope ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Envelope >
    _xsd_Envelope_type_factory_init (
      L"Envelope",
      L"http://www.w3.org/2003/05/soap-envelope");

    // Header
    //

    Header::
    Header ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
    }

    Header::
    Header (const Header& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    Header::
    Header (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void Header::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if (true)
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"http://www.w3.org/2003/05/soap-envelope" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Header* Header::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Header (*this, f, c);
    }

    Header::
    ~Header ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Header >
    _xsd_Header_type_factory_init (
      L"Header",
      L"http://www.w3.org/2003/05/soap-envelope");

    // Body
    //

    Body::
    Body ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
    }

    Body::
    Body (const Body& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    Body::
    Body (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void Body::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if (true)
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"http://www.w3.org/2003/05/soap-envelope" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    Body* Body::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Body (*this, f, c);
    }

    Body::
    ~Body ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Body >
    _xsd_Body_type_factory_init (
      L"Body",
      L"http://www.w3.org/2003/05/soap-envelope");

    // Fault
    //

    Fault::
    Fault ()
    : ::xml_schema::type (),
      Code_ (::xml_schema::flags (), this),
      Reason_ (::xml_schema::flags (), this),
      Node_ (::xml_schema::flags (), this),
      Role_ (::xml_schema::flags (), this),
      Detail_ (::xml_schema::flags (), this)
    {
    }

    Fault::
    Fault (const Code_type& Code,
           const Reason_type& Reason)
    : ::xml_schema::type (),
      Code_ (Code, ::xml_schema::flags (), this),
      Reason_ (Reason, ::xml_schema::flags (), this),
      Node_ (::xml_schema::flags (), this),
      Role_ (::xml_schema::flags (), this),
      Detail_ (::xml_schema::flags (), this)
    {
    }

    Fault::
    Fault (::std::auto_ptr< Code_type >& Code,
           ::std::auto_ptr< Reason_type >& Reason)
    : ::xml_schema::type (),
      Code_ (Code, ::xml_schema::flags (), this),
      Reason_ (Reason, ::xml_schema::flags (), this),
      Node_ (::xml_schema::flags (), this),
      Role_ (::xml_schema::flags (), this),
      Detail_ (::xml_schema::flags (), this)
    {
    }

    Fault::
    Fault (const Fault& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Code_ (x.Code_, f, this),
      Reason_ (x.Reason_, f, this),
      Node_ (x.Node_, f, this),
      Role_ (x.Role_, f, this),
      Detail_ (x.Detail_, f, this)
    {
    }

    Fault::
    Fault (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Code_ (f, this),
      Reason_ (f, this),
      Node_ (f, this),
      Role_ (f, this),
      Detail_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void Fault::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Code
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Code",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Code_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Code_.present ())
            {
              ::std::auto_ptr< Code_type > r (
                dynamic_cast< Code_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Code_.set (r);
              continue;
            }
          }
        }

        // Reason
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Reason",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Reason_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Reason_.present ())
            {
              ::std::auto_ptr< Reason_type > r (
                dynamic_cast< Reason_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Reason_.set (r);
              continue;
            }
          }
        }

        // Node
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Node",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Node_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Node_)
            {
              ::std::auto_ptr< Node_type > r (
                dynamic_cast< Node_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Node_.set (r);
              continue;
            }
          }
        }

        // Role
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Role",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Role_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Role_)
            {
              ::std::auto_ptr< Role_type > r (
                dynamic_cast< Role_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Role_.set (r);
              continue;
            }
          }
        }

        // Detail
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Detail",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Detail_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Detail_)
            {
              ::std::auto_ptr< Detail_type > r (
                dynamic_cast< Detail_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Detail_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!Code_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Code",
          L"http://www.w3.org/2003/05/soap-envelope");
      }

      if (!Reason_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Reason",
          L"http://www.w3.org/2003/05/soap-envelope");
      }
    }

    Fault* Fault::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class Fault (*this, f, c);
    }

    Fault::
    ~Fault ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, Fault >
    _xsd_Fault_type_factory_init (
      L"Fault",
      L"http://www.w3.org/2003/05/soap-envelope");

    // faultreason
    //

    faultreason::
    faultreason ()
    : ::xml_schema::type (),
      Text_ (::xml_schema::flags (), this)
    {
    }

    faultreason::
    faultreason (const faultreason& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Text_ (x.Text_, f, this)
    {
    }

    faultreason::
    faultreason (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Text_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void faultreason::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Text
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Text",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Text_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< Text_type > r (
              dynamic_cast< Text_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->Text_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    faultreason* faultreason::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class faultreason (*this, f, c);
    }

    faultreason::
    ~faultreason ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, faultreason >
    _xsd_faultreason_type_factory_init (
      L"faultreason",
      L"http://www.w3.org/2003/05/soap-envelope");

    // reasontext
    //

    reasontext::
    reasontext ()
    : ::xml_schema::string (),
      lang_ (::xml_schema::flags (), this)
    {
    }

    reasontext::
    reasontext (const lang_type& lang)
    : ::xml_schema::string (),
      lang_ (lang, ::xml_schema::flags (), this)
    {
    }

    reasontext::
    reasontext (const wchar_t* _xsd_string_base,
                const lang_type& lang)
    : ::xml_schema::string (_xsd_string_base),
      lang_ (lang, ::xml_schema::flags (), this)
    {
    }

    reasontext::
    reasontext (const ::std::wstring& _xsd_string_base,
                const lang_type& lang)
    : ::xml_schema::string (_xsd_string_base),
      lang_ (lang, ::xml_schema::flags (), this)
    {
    }

    reasontext::
    reasontext (const ::xml_schema::string& _xsd_string_base,
                const lang_type& lang)
    : ::xml_schema::string (_xsd_string_base),
      lang_ (lang, ::xml_schema::flags (), this)
    {
    }

    reasontext::
    reasontext (const reasontext& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (x, f, c),
      lang_ (x.lang_, f, this)
    {
    }

    reasontext::
    reasontext (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
      lang_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, true);
        this->parse (p, f);
      }
    }

    void reasontext::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"lang" && n.namespace_ () == L"http://www.w3.org/XML/1998/namespace")
        {
          ::std::auto_ptr< lang_type > r (
            lang_traits::create (i, f, this));

          this->lang_.set (r);
          continue;
        }
      }

      if (!lang_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"lang",
          L"http://www.w3.org/XML/1998/namespace");
      }
    }

    reasontext* reasontext::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class reasontext (*this, f, c);
    }

    reasontext::
    ~reasontext ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, reasontext >
    _xsd_reasontext_type_factory_init (
      L"reasontext",
      L"http://www.w3.org/2003/05/soap-envelope");

    // faultcode
    //

    faultcode::
    faultcode ()
    : ::xml_schema::type (),
      Value_ (::xml_schema::flags (), this),
      Subcode_ (::xml_schema::flags (), this)
    {
    }

    faultcode::
    faultcode (const Value_type& Value)
    : ::xml_schema::type (),
      Value_ (Value, ::xml_schema::flags (), this),
      Subcode_ (::xml_schema::flags (), this)
    {
    }

    faultcode::
    faultcode (::std::auto_ptr< Value_type >& Value)
    : ::xml_schema::type (),
      Value_ (Value, ::xml_schema::flags (), this),
      Subcode_ (::xml_schema::flags (), this)
    {
    }

    faultcode::
    faultcode (const faultcode& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Value_ (x.Value_, f, this),
      Subcode_ (x.Subcode_, f, this)
    {
    }

    faultcode::
    faultcode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Value_ (f, this),
      Subcode_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void faultcode::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Value
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Value",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Value_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Value_.present ())
            {
              ::std::auto_ptr< Value_type > r (
                dynamic_cast< Value_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Value_.set (r);
              continue;
            }
          }
        }

        // Subcode
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Subcode",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Subcode_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Subcode_)
            {
              ::std::auto_ptr< Subcode_type > r (
                dynamic_cast< Subcode_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Subcode_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Value",
          L"http://www.w3.org/2003/05/soap-envelope");
      }
    }

    faultcode* faultcode::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class faultcode (*this, f, c);
    }

    faultcode::
    ~faultcode ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, faultcode >
    _xsd_faultcode_type_factory_init (
      L"faultcode",
      L"http://www.w3.org/2003/05/soap-envelope");

    // faultcodeEnum
    //

    faultcodeEnum::
    faultcodeEnum (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::qname (e, f, c)
    {
    }

    faultcodeEnum::
    faultcodeEnum (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::qname (a, f, c)
    {
    }

    faultcodeEnum::
    faultcodeEnum (const ::std::wstring& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::qname (s, e, f, c)
    {
    }

    faultcodeEnum* faultcodeEnum::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class faultcodeEnum (*this, f, c);
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, faultcodeEnum >
    _xsd_faultcodeEnum_type_factory_init (
      L"faultcodeEnum",
      L"http://www.w3.org/2003/05/soap-envelope");

    // subcode
    //

    subcode::
    subcode ()
    : ::xml_schema::type (),
      Value_ (::xml_schema::flags (), this),
      Subcode_ (::xml_schema::flags (), this)
    {
    }

    subcode::
    subcode (const Value_type& Value)
    : ::xml_schema::type (),
      Value_ (Value, ::xml_schema::flags (), this),
      Subcode_ (::xml_schema::flags (), this)
    {
    }

    subcode::
    subcode (::std::auto_ptr< Value_type >& Value)
    : ::xml_schema::type (),
      Value_ (Value, ::xml_schema::flags (), this),
      Subcode_ (::xml_schema::flags (), this)
    {
    }

    subcode::
    subcode (const subcode& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      Value_ (x.Value_, f, this),
      Subcode_ (x.Subcode_, f, this)
    {
    }

    subcode::
    subcode (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      Value_ (f, this),
      Subcode_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void subcode::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // Value
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Value",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Value_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!Value_.present ())
            {
              ::std::auto_ptr< Value_type > r (
                dynamic_cast< Value_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Value_.set (r);
              continue;
            }
          }
        }

        // Subcode
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"Subcode",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< Subcode_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            if (!this->Subcode_)
            {
              ::std::auto_ptr< Subcode_type > r (
                dynamic_cast< Subcode_type* > (tmp.get ()));

              if (r.get ())
                tmp.release ();
              else
                throw ::xsd::cxx::tree::not_derived< wchar_t > ();

              this->Subcode_.set (r);
              continue;
            }
          }
        }

        break;
      }

      if (!Value_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"Value",
          L"http://www.w3.org/2003/05/soap-envelope");
      }
    }

    subcode* subcode::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class subcode (*this, f, c);
    }

    subcode::
    ~subcode ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, subcode >
    _xsd_subcode_type_factory_init (
      L"subcode",
      L"http://www.w3.org/2003/05/soap-envelope");

    // detail
    //

    detail::
    detail ()
    : ::xml_schema::type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
    }

    detail::
    detail (const detail& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (x.any_, this->dom_document ()),
      any_attribute_ (x.any_attribute_, this->dom_document ())
    {
    }

    detail::
    detail (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< wchar_t > ()),
      any_ (this->dom_document ()),
      any_attribute_ (this->dom_document ())
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void detail::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any
        //
        if (true)
        {
          ::xercesc::DOMElement* r (
            static_cast< ::xercesc::DOMElement* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMElement* > (&i), true)));
          this->any_ .push_back (r);
          continue;
        }

        break;
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // any_attribute
        //
        if ((!n.namespace_ ().empty () &&
             n.namespace_ () != L"http://www.w3.org/2003/05/soap-envelope" &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xmlns_namespace< wchar_t > () &&
             n.namespace_ () != ::xsd::cxx::xml::bits::xsi_namespace< wchar_t > ()))
        {
          ::xercesc::DOMAttr* r (
            static_cast< ::xercesc::DOMAttr* > (
              this->dom_document ().importNode (
                const_cast< ::xercesc::DOMAttr* > (&i), true)));
          this->any_attribute_ .insert (r);
          continue;
        }
      }
    }

    detail* detail::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class detail (*this, f, c);
    }

    detail::
    ~detail ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, detail >
    _xsd_detail_type_factory_init (
      L"detail",
      L"http://www.w3.org/2003/05/soap-envelope");

    // NotUnderstoodType
    //

    NotUnderstoodType::
    NotUnderstoodType ()
    : ::xml_schema::type (),
      qname_ (::xml_schema::flags (), this)
    {
    }

    NotUnderstoodType::
    NotUnderstoodType (const qname_type& qname)
    : ::xml_schema::type (),
      qname_ (qname, ::xml_schema::flags (), this)
    {
    }

    NotUnderstoodType::
    NotUnderstoodType (const NotUnderstoodType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      qname_ (x.qname_, f, this)
    {
    }

    NotUnderstoodType::
    NotUnderstoodType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      qname_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, true);
        this->parse (p, f);
      }
    }

    void NotUnderstoodType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"qname" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< qname_type > r (
            qname_traits::create (i, f, this));

          this->qname_.set (r);
          continue;
        }
      }

      if (!qname_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"qname",
          L"");
      }
    }

    NotUnderstoodType* NotUnderstoodType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class NotUnderstoodType (*this, f, c);
    }

    NotUnderstoodType::
    ~NotUnderstoodType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, NotUnderstoodType >
    _xsd_NotUnderstoodType_type_factory_init (
      L"NotUnderstoodType",
      L"http://www.w3.org/2003/05/soap-envelope");

    // SupportedEnvType
    //

    SupportedEnvType::
    SupportedEnvType ()
    : ::xml_schema::type (),
      qname_ (::xml_schema::flags (), this)
    {
    }

    SupportedEnvType::
    SupportedEnvType (const qname_type& qname)
    : ::xml_schema::type (),
      qname_ (qname, ::xml_schema::flags (), this)
    {
    }

    SupportedEnvType::
    SupportedEnvType (const SupportedEnvType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      qname_ (x.qname_, f, this)
    {
    }

    SupportedEnvType::
    SupportedEnvType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      qname_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, false, true);
        this->parse (p, f);
      }
    }

    void SupportedEnvType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"qname" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< qname_type > r (
            qname_traits::create (i, f, this));

          this->qname_.set (r);
          continue;
        }
      }

      if (!qname_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"qname",
          L"");
      }
    }

    SupportedEnvType* SupportedEnvType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class SupportedEnvType (*this, f, c);
    }

    SupportedEnvType::
    ~SupportedEnvType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, SupportedEnvType >
    _xsd_SupportedEnvType_type_factory_init (
      L"SupportedEnvType",
      L"http://www.w3.org/2003/05/soap-envelope");

    // UpgradeType
    //

    UpgradeType::
    UpgradeType ()
    : ::xml_schema::type (),
      SupportedEnvelope_ (::xml_schema::flags (), this)
    {
    }

    UpgradeType::
    UpgradeType (const UpgradeType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      SupportedEnvelope_ (x.SupportedEnvelope_, f, this)
    {
    }

    UpgradeType::
    UpgradeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      SupportedEnvelope_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void UpgradeType::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // SupportedEnvelope
        //
        {
          ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
            ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

          ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
            tfm.create (
              L"SupportedEnvelope",
              L"http://www.w3.org/2003/05/soap-envelope",
              &::xsd::cxx::tree::factory_impl< SupportedEnvelope_type >,
              false, true, i, n, f, this));

          if (tmp.get () != 0)
          {
            ::std::auto_ptr< SupportedEnvelope_type > r (
              dynamic_cast< SupportedEnvelope_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< wchar_t > ();

            this->SupportedEnvelope_.push_back (r);
            continue;
          }
        }

        break;
      }
    }

    UpgradeType* UpgradeType::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class UpgradeType (*this, f, c);
    }

    UpgradeType::
    ~UpgradeType ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, wchar_t, UpgradeType >
    _xsd_UpgradeType_type_factory_init (
      L"UpgradeType",
      L"http://www.w3.org/2003/05/soap-envelope");
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace soap
{
  namespace v12
  {
    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (const ::std::wstring& u,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::Envelope > r (
        ::soap::v12::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (const ::std::wstring& u,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Envelope > r (
        ::soap::v12::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (const ::std::wstring& u,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Envelope > r (
        ::soap::v12::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Envelope_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Envelope_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Envelope_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Envelope_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               const ::std::wstring& sid,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Envelope_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::std::istream& is,
               const ::std::wstring& sid,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Envelope_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::xercesc::InputSource& i,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::Envelope > r (
        ::soap::v12::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::xercesc::InputSource& i,
               ::xml_schema::error_handler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Envelope > r (
        ::soap::v12::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::xercesc::InputSource& i,
               ::xercesc::DOMErrorHandler& h,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Envelope > r (
        ::soap::v12::Envelope_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (const ::xercesc::DOMDocument& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v12::Envelope > r (
          ::soap::v12::Envelope_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Envelope",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::Envelope >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v12::Envelope > r (
          dynamic_cast< ::soap::v12::Envelope* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Envelope",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::Envelope >
    Envelope_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
               ::xml_schema::flags f,
               const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Envelope",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::Envelope >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v12::Envelope > r (
          dynamic_cast< ::soap::v12::Envelope* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Envelope",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::Header > r (
        ::soap::v12::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Header > r (
        ::soap::v12::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Header > r (
        ::soap::v12::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Header_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Header_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Header_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Header_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Header_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Header_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::Header > r (
        ::soap::v12::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Header > r (
        ::soap::v12::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Header > r (
        ::soap::v12::Header_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v12::Header > r (
          ::soap::v12::Header_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Header",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::Header >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v12::Header > r (
          dynamic_cast< ::soap::v12::Header* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Header",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::Header >
    Header_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Header",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::Header >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v12::Header > r (
          dynamic_cast< ::soap::v12::Header* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Header",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (const ::std::wstring& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::Body > r (
        ::soap::v12::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (const ::std::wstring& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Body > r (
        ::soap::v12::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (const ::std::wstring& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Body > r (
        ::soap::v12::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Body_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Body_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Body_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           const ::std::wstring& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Body_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           const ::std::wstring& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Body_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::std::istream& is,
           const ::std::wstring& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Body_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::Body > r (
        ::soap::v12::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Body > r (
        ::soap::v12::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Body > r (
        ::soap::v12::Body_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v12::Body > r (
          ::soap::v12::Body_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Body",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::Body >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v12::Body > r (
          dynamic_cast< ::soap::v12::Body* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Body",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::Body >
    Body_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Body",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::Body >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v12::Body > r (
          dynamic_cast< ::soap::v12::Body* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Body",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (const ::std::wstring& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::Fault > r (
        ::soap::v12::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (const ::std::wstring& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Fault > r (
        ::soap::v12::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (const ::std::wstring& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Fault > r (
        ::soap::v12::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Fault_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Fault_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Fault_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Fault_ (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            const ::std::wstring& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Fault_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::std::istream& is,
            const ::std::wstring& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Fault_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::Fault > r (
        ::soap::v12::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Fault > r (
        ::soap::v12::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::Fault > r (
        ::soap::v12::Fault_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v12::Fault > r (
          ::soap::v12::Fault_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Fault",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::Fault >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v12::Fault > r (
          dynamic_cast< ::soap::v12::Fault* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Fault",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::Fault >
    Fault_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Fault",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::Fault >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v12::Fault > r (
          dynamic_cast< ::soap::v12::Fault* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Fault",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (const ::std::wstring& u,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::NotUnderstoodType > r (
        ::soap::v12::NotUnderstood (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (const ::std::wstring& u,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::NotUnderstoodType > r (
        ::soap::v12::NotUnderstood (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (const ::std::wstring& u,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::NotUnderstoodType > r (
        ::soap::v12::NotUnderstood (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::NotUnderstood (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::NotUnderstood (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::NotUnderstood (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::NotUnderstood (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::NotUnderstood (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::std::istream& is,
                   const ::std::wstring& sid,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::NotUnderstood (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::xercesc::InputSource& i,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::NotUnderstoodType > r (
        ::soap::v12::NotUnderstood (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::xercesc::InputSource& i,
                   ::xml_schema::error_handler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::NotUnderstoodType > r (
        ::soap::v12::NotUnderstood (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::xercesc::InputSource& i,
                   ::xercesc::DOMErrorHandler& h,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::NotUnderstoodType > r (
        ::soap::v12::NotUnderstood (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (const ::xercesc::DOMDocument& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v12::NotUnderstoodType > r (
          ::soap::v12::NotUnderstood (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"NotUnderstood",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::NotUnderstoodType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v12::NotUnderstoodType > r (
          dynamic_cast< ::soap::v12::NotUnderstoodType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NotUnderstood",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::NotUnderstoodType >
    NotUnderstood (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                   ::xml_schema::flags f,
                   const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"NotUnderstood",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::NotUnderstoodType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v12::NotUnderstoodType > r (
          dynamic_cast< ::soap::v12::NotUnderstoodType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"NotUnderstood",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::UpgradeType > r (
        ::soap::v12::Upgrade (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::UpgradeType > r (
        ::soap::v12::Upgrade (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::UpgradeType > r (
        ::soap::v12::Upgrade (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Upgrade (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Upgrade (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::soap::v12::Upgrade (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Upgrade (isrc, f, p);
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Upgrade (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::soap::v12::Upgrade (isrc, h, f, p);
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::soap::v12::UpgradeType > r (
        ::soap::v12::Upgrade (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::UpgradeType > r (
        ::soap::v12::Upgrade (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::soap::v12::UpgradeType > r (
        ::soap::v12::Upgrade (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::soap::v12::UpgradeType > r (
          ::soap::v12::Upgrade (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Upgrade",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::UpgradeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< ::soap::v12::UpgradeType > r (
          dynamic_cast< ::soap::v12::UpgradeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Upgrade",
        L"http://www.w3.org/2003/05/soap-envelope");
    }

    ::std::auto_ptr< ::soap::v12::UpgradeType >
    Upgrade (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      ::xsd::cxx::tree::type_factory_map< wchar_t >& tfm (
        ::xsd::cxx::tree::type_factory_map_instance< 0, wchar_t > ());

      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        tfm.create (
          L"Upgrade",
          L"http://www.w3.org/2003/05/soap-envelope",
          &::xsd::cxx::tree::factory_impl< ::soap::v12::UpgradeType >,
          true, true, e, n, f, 0));

      if (tmp.get () != 0)
      {

        ::std::auto_ptr< ::soap::v12::UpgradeType > r (
          dynamic_cast< ::soap::v12::UpgradeType* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< wchar_t > ();

        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"Upgrade",
        L"http://www.w3.org/2003/05/soap-envelope");
    }
  }
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, wchar_t >
  type_serializer_plate_init;
}

namespace soap
{
  namespace v12
  {
    void
    Envelope_ (::std::ostream& o,
               const ::soap::v12::Envelope& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Envelope_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Envelope_ (::std::ostream& o,
               const ::soap::v12::Envelope& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Envelope_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Envelope_ (::std::ostream& o,
               const ::soap::v12::Envelope& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Envelope_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Envelope_ (::xercesc::XMLFormatTarget& t,
               const ::soap::v12::Envelope& s,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Envelope_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Envelope_ (::xercesc::XMLFormatTarget& t,
               const ::soap::v12::Envelope& s,
               ::xml_schema::error_handler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Envelope_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Envelope_ (::xercesc::XMLFormatTarget& t,
               const ::soap::v12::Envelope& s,
               ::xercesc::DOMErrorHandler& h,
               const ::xml_schema::namespace_infomap& m,
               const ::std::wstring& e,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Envelope_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Envelope_ (::xercesc::DOMDocument& d,
               const ::soap::v12::Envelope& s,
               ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v12::Envelope) == typeid (s))
      {
        if (n.name () == L"Envelope" &&
            n.namespace_ () == L"http://www.w3.org/2003/05/soap-envelope")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Envelope",
            L"http://www.w3.org/2003/05/soap-envelope");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Envelope",
          L"http://www.w3.org/2003/05/soap-envelope",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Envelope_ (const ::soap::v12::Envelope& s,
               const ::xml_schema::namespace_infomap& m,
               ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v12::Envelope) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Envelope",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"Envelope",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, s, f));
        d = r;
      }

      ::soap::v12::Envelope_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Envelope& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (Envelope::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // Header
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Header ())
        {
          const Envelope::Header_type& x (*i.Header ());
          if (typeid (Envelope::Header_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Header",
                L"http://www.w3.org/2003/05/soap-envelope",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Header",
              L"http://www.w3.org/2003/05/soap-envelope",
              true, true, e, x);
        }
      }

      // Body
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Envelope::Body_type& x (i.Body ());
        if (typeid (Envelope::Body_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Body",
              L"http://www.w3.org/2003/05/soap-envelope",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Body",
            L"http://www.w3.org/2003/05/soap-envelope",
            true, true, e, x);
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Envelope >
    _xsd_Envelope_type_serializer_init (
      L"Envelope",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    Header_ (::std::ostream& o,
             const ::soap::v12::Header& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Header_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Header_ (::std::ostream& o,
             const ::soap::v12::Header& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Header_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Header_ (::std::ostream& o,
             const ::soap::v12::Header& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Header_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Header_ (::xercesc::XMLFormatTarget& t,
             const ::soap::v12::Header& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Header_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Header_ (::xercesc::XMLFormatTarget& t,
             const ::soap::v12::Header& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Header_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Header_ (::xercesc::XMLFormatTarget& t,
             const ::soap::v12::Header& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Header_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Header_ (::xercesc::DOMDocument& d,
             const ::soap::v12::Header& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v12::Header) == typeid (s))
      {
        if (n.name () == L"Header" &&
            n.namespace_ () == L"http://www.w3.org/2003/05/soap-envelope")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Header",
            L"http://www.w3.org/2003/05/soap-envelope");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Header",
          L"http://www.w3.org/2003/05/soap-envelope",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Header_ (const ::soap::v12::Header& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v12::Header) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Header",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"Header",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, s, f));
        d = r;
      }

      ::soap::v12::Header_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Header& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (Header::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // any
      //
      for (Header::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Header >
    _xsd_Header_type_serializer_init (
      L"Header",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    Body_ (::std::ostream& o,
           const ::soap::v12::Body& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Body_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Body_ (::std::ostream& o,
           const ::soap::v12::Body& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Body_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Body_ (::std::ostream& o,
           const ::soap::v12::Body& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Body_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Body_ (::xercesc::XMLFormatTarget& t,
           const ::soap::v12::Body& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Body_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Body_ (::xercesc::XMLFormatTarget& t,
           const ::soap::v12::Body& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Body_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Body_ (::xercesc::XMLFormatTarget& t,
           const ::soap::v12::Body& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::wstring& e,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Body_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Body_ (::xercesc::DOMDocument& d,
           const ::soap::v12::Body& s,
           ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v12::Body) == typeid (s))
      {
        if (n.name () == L"Body" &&
            n.namespace_ () == L"http://www.w3.org/2003/05/soap-envelope")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Body",
            L"http://www.w3.org/2003/05/soap-envelope");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Body",
          L"http://www.w3.org/2003/05/soap-envelope",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Body_ (const ::soap::v12::Body& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v12::Body) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Body",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"Body",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, s, f));
        d = r;
      }

      ::soap::v12::Body_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Body& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (Body::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // any
      //
      for (Body::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Body >
    _xsd_Body_type_serializer_init (
      L"Body",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    Fault_ (::std::ostream& o,
            const ::soap::v12::Fault& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Fault_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Fault_ (::std::ostream& o,
            const ::soap::v12::Fault& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Fault_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Fault_ (::std::ostream& o,
            const ::soap::v12::Fault& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Fault_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Fault_ (::xercesc::XMLFormatTarget& t,
            const ::soap::v12::Fault& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Fault_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Fault_ (::xercesc::XMLFormatTarget& t,
            const ::soap::v12::Fault& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Fault_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Fault_ (::xercesc::XMLFormatTarget& t,
            const ::soap::v12::Fault& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::wstring& e,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Fault_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Fault_ (::xercesc::DOMDocument& d,
            const ::soap::v12::Fault& s,
            ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v12::Fault) == typeid (s))
      {
        if (n.name () == L"Fault" &&
            n.namespace_ () == L"http://www.w3.org/2003/05/soap-envelope")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Fault",
            L"http://www.w3.org/2003/05/soap-envelope");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Fault",
          L"http://www.w3.org/2003/05/soap-envelope",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Fault_ (const ::soap::v12::Fault& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v12::Fault) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Fault",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"Fault",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, s, f));
        d = r;
      }

      ::soap::v12::Fault_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const Fault& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Code
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Fault::Code_type& x (i.Code ());
        if (typeid (Fault::Code_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Code",
              L"http://www.w3.org/2003/05/soap-envelope",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Code",
            L"http://www.w3.org/2003/05/soap-envelope",
            false, true, e, x);
      }

      // Reason
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const Fault::Reason_type& x (i.Reason ());
        if (typeid (Fault::Reason_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Reason",
              L"http://www.w3.org/2003/05/soap-envelope",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Reason",
            L"http://www.w3.org/2003/05/soap-envelope",
            false, true, e, x);
      }

      // Node
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Node ())
        {
          const Fault::Node_type& x (*i.Node ());
          if (typeid (Fault::Node_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Node",
                L"http://www.w3.org/2003/05/soap-envelope",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Node",
              L"http://www.w3.org/2003/05/soap-envelope",
              false, true, e, x);
        }
      }

      // Role
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Role ())
        {
          const Fault::Role_type& x (*i.Role ());
          if (typeid (Fault::Role_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Role",
                L"http://www.w3.org/2003/05/soap-envelope",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Role",
              L"http://www.w3.org/2003/05/soap-envelope",
              false, true, e, x);
        }
      }

      // Detail
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Detail ())
        {
          const Fault::Detail_type& x (*i.Detail ());
          if (typeid (Fault::Detail_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Detail",
                L"http://www.w3.org/2003/05/soap-envelope",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Detail",
              L"http://www.w3.org/2003/05/soap-envelope",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, Fault >
    _xsd_Fault_type_serializer_init (
      L"Fault",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    operator<< (::xercesc::DOMElement& e, const faultreason& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Text
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (faultreason::Text_const_iterator
             b (i.Text ().begin ()), n (i.Text ().end ());
             b != n; ++b)
        {
          if (typeid (faultreason::Text_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Text",
                L"http://www.w3.org/2003/05/soap-envelope",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"Text",
              L"http://www.w3.org/2003/05/soap-envelope",
              false, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, faultreason >
    _xsd_faultreason_type_serializer_init (
      L"faultreason",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    operator<< (::xercesc::DOMElement& e, const reasontext& i)
    {
      e << static_cast< const ::xml_schema::string& > (i);

      // lang
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"lang",
            L"http://www.w3.org/XML/1998/namespace",
            e));

        a << i.lang ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, reasontext >
    _xsd_reasontext_type_serializer_init (
      L"reasontext",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    operator<< (::xercesc::DOMElement& e, const faultcode& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Value
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const faultcode::Value_type& x (i.Value ());
        if (typeid (faultcode::Value_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Value",
              L"http://www.w3.org/2003/05/soap-envelope",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Value",
            L"http://www.w3.org/2003/05/soap-envelope",
            false, true, e, x);
      }

      // Subcode
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Subcode ())
        {
          const faultcode::Subcode_type& x (*i.Subcode ());
          if (typeid (faultcode::Subcode_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Subcode",
                L"http://www.w3.org/2003/05/soap-envelope",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Subcode",
              L"http://www.w3.org/2003/05/soap-envelope",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, faultcode >
    _xsd_faultcode_type_serializer_init (
      L"faultcode",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    operator<< (::xercesc::DOMElement& e, const faultcodeEnum& i)
    {
      e << static_cast< const ::xml_schema::qname& > (i);
    }

    void
    operator<< (::xercesc::DOMAttr& a, const faultcodeEnum& i)
    {
      a << static_cast< const ::xml_schema::qname& > (i);
    }

    void
    operator<< (::xml_schema::list_stream& l,
                const faultcodeEnum& i)
    {
      l << static_cast< const ::xml_schema::qname& > (i);
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, faultcodeEnum >
    _xsd_faultcodeEnum_type_serializer_init (
      L"faultcodeEnum",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    operator<< (::xercesc::DOMElement& e, const subcode& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // Value
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        const subcode::Value_type& x (i.Value ());
        if (typeid (subcode::Value_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              L"Value",
              L"http://www.w3.org/2003/05/soap-envelope",
              e));

          s << x;
        }
        else
          tsm.serialize (
            L"Value",
            L"http://www.w3.org/2003/05/soap-envelope",
            false, true, e, x);
      }

      // Subcode
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        if (i.Subcode ())
        {
          const subcode::Subcode_type& x (*i.Subcode ());
          if (typeid (subcode::Subcode_type) == typeid (x))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"Subcode",
                L"http://www.w3.org/2003/05/soap-envelope",
                e));

            s << x;
          }
          else
            tsm.serialize (
              L"Subcode",
              L"http://www.w3.org/2003/05/soap-envelope",
              false, true, e, x);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, subcode >
    _xsd_subcode_type_serializer_init (
      L"subcode",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    operator<< (::xercesc::DOMElement& e, const detail& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // any_attribute
      //
      for (detail::any_attribute_const_iterator
           b (i.any_attribute ().begin ()), n (i.any_attribute ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMAttr* a (
          static_cast< ::xercesc::DOMAttr* > (
            e.getOwnerDocument ()->importNode (
              const_cast< ::xercesc::DOMAttr* > (&(*b)), true)));

        if (a->getLocalName () == 0)
          e.setAttributeNode (a);
        else
          e.setAttributeNodeNS (a);
      }

      // any
      //
      for (detail::any_const_iterator
           b (i.any ().begin ()), n (i.any ().end ());
           b != n; ++b)
      {
        e.appendChild (
          e.getOwnerDocument ()->importNode (
            const_cast< ::xercesc::DOMElement* > (&(*b)), true));
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, detail >
    _xsd_detail_type_serializer_init (
      L"detail",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    NotUnderstood (::std::ostream& o,
                   const ::soap::v12::NotUnderstoodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::NotUnderstood (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NotUnderstood (::std::ostream& o,
                   const ::soap::v12::NotUnderstoodType& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::NotUnderstood (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NotUnderstood (::std::ostream& o,
                   const ::soap::v12::NotUnderstoodType& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::NotUnderstood (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NotUnderstood (::xercesc::XMLFormatTarget& t,
                   const ::soap::v12::NotUnderstoodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::NotUnderstood (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    NotUnderstood (::xercesc::XMLFormatTarget& t,
                   const ::soap::v12::NotUnderstoodType& s,
                   ::xml_schema::error_handler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::NotUnderstood (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NotUnderstood (::xercesc::XMLFormatTarget& t,
                   const ::soap::v12::NotUnderstoodType& s,
                   ::xercesc::DOMErrorHandler& h,
                   const ::xml_schema::namespace_infomap& m,
                   const ::std::wstring& e,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::NotUnderstood (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    NotUnderstood (::xercesc::DOMDocument& d,
                   const ::soap::v12::NotUnderstoodType& s,
                   ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v12::NotUnderstoodType) == typeid (s))
      {
        if (n.name () == L"NotUnderstood" &&
            n.namespace_ () == L"http://www.w3.org/2003/05/soap-envelope")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"NotUnderstood",
            L"http://www.w3.org/2003/05/soap-envelope");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"NotUnderstood",
          L"http://www.w3.org/2003/05/soap-envelope",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    NotUnderstood (const ::soap::v12::NotUnderstoodType& s,
                   const ::xml_schema::namespace_infomap& m,
                   ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v12::NotUnderstoodType) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"NotUnderstood",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"NotUnderstood",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, s, f));
        d = r;
      }

      ::soap::v12::NotUnderstood (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const NotUnderstoodType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // qname
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"qname",
            e));

        a << i.qname ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, NotUnderstoodType >
    _xsd_NotUnderstoodType_type_serializer_init (
      L"NotUnderstoodType",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    operator<< (::xercesc::DOMElement& e, const SupportedEnvType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // qname
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"qname",
            e));

        a << i.qname ();
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, SupportedEnvType >
    _xsd_SupportedEnvType_type_serializer_init (
      L"SupportedEnvType",
      L"http://www.w3.org/2003/05/soap-envelope");


    void
    Upgrade (::std::ostream& o,
             const ::soap::v12::UpgradeType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Upgrade (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Upgrade (::std::ostream& o,
             const ::soap::v12::UpgradeType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Upgrade (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Upgrade (::std::ostream& o,
             const ::soap::v12::UpgradeType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Upgrade (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Upgrade (::xercesc::XMLFormatTarget& t,
             const ::soap::v12::UpgradeType& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Upgrade (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    Upgrade (::xercesc::XMLFormatTarget& t,
             const ::soap::v12::UpgradeType& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Upgrade (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Upgrade (::xercesc::XMLFormatTarget& t,
             const ::soap::v12::UpgradeType& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::soap::v12::Upgrade (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    Upgrade (::xercesc::DOMDocument& d,
             const ::soap::v12::UpgradeType& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (typeid (::soap::v12::UpgradeType) == typeid (s))
      {
        if (n.name () == L"Upgrade" &&
            n.namespace_ () == L"http://www.w3.org/2003/05/soap-envelope")
        {
          e << s;
        }
        else
        {
          throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
            n.name (),
            n.namespace_ (),
            L"Upgrade",
            L"http://www.w3.org/2003/05/soap-envelope");
        }
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        tsm.serialize (
          L"Upgrade",
          L"http://www.w3.org/2003/05/soap-envelope",
          e, n, s);
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Upgrade (const ::soap::v12::UpgradeType& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

      if (typeid (::soap::v12::UpgradeType) == typeid (s))
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          ::xsd::cxx::xml::dom::serialize< wchar_t > (
            L"Upgrade",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, f));
        d = r;
      }
      else
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > r (
          tsm.serialize (
            L"Upgrade",
            L"http://www.w3.org/2003/05/soap-envelope",
            m, s, f));
        d = r;
      }

      ::soap::v12::Upgrade (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const UpgradeType& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // SupportedEnvelope
      //
      {
        ::xsd::cxx::tree::type_serializer_map< wchar_t >& tsm (
          ::xsd::cxx::tree::type_serializer_map_instance< 0, wchar_t > ());

        for (UpgradeType::SupportedEnvelope_const_iterator
             b (i.SupportedEnvelope ().begin ()), n (i.SupportedEnvelope ().end ());
             b != n; ++b)
        {
          if (typeid (UpgradeType::SupportedEnvelope_type) == typeid (*b))
          {
            ::xercesc::DOMElement& s (
              ::xsd::cxx::xml::dom::create_element (
                L"SupportedEnvelope",
                L"http://www.w3.org/2003/05/soap-envelope",
                e));

            s << *b;
          }
          else
            tsm.serialize (
              L"SupportedEnvelope",
              L"http://www.w3.org/2003/05/soap-envelope",
              false, true, e, *b);
        }
      }
    }

    static
    const ::xsd::cxx::tree::type_serializer_initializer< 0, wchar_t, UpgradeType >
    _xsd_UpgradeType_type_serializer_init (
      L"UpgradeType",
      L"http://www.w3.org/2003/05/soap-envelope");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

